import { GetFileNodesResponse } from '@figma/rest-api-spec';
import { GetFileResponse } from '@figma/rest-api-spec';
import { GetImagesResponse } from '@figma/rest-api-spec';

declare interface API {
    resourceName: string;
    [key: string | symbol]: any;
}

declare type AsyncRequestOptions = {
    pollingInterval?: (pollingNumber: number) => number;
    maxTimeout?: number;
    onProgress?: (payload: Record<string, any>) => void;
    abortSignal?: AbortSignal;
};

declare type Cache_2 = {
    images: ResourceCache<GetImagesResponse>;
};

export declare type CacheResponse<T> = {
    ts: number;
    result: T;
};

export declare class FigmaRestApi extends HTTPClient implements iFigmaRestApi {
    #private;
    cache: Cache_2;
    files: Files;
    nodes: Nodes;
    images: Images;
    constructor({ baseAddress, fetch, }?: FigmaRestApiConstructor);
    set token(token: string);
    get token(): string;
    get headers(): Record<string, string>;
}

export declare type FigmaRestApiConstructor = {
    baseAddress?: string;
    fetch?: typeof globalThis.fetch;
};

declare class Files implements API {
    #private;
    resourceName: string;
    constructor(figmaRestApi: FigmaRestApi);
    get({ fileKey, params }: GetFileParams): Promise<GetFileResponse>;
    getImageFills({ fileKey }: {
        fileKey: string;
    }): Promise<{
        [key: string]: string;
    }>;
}

declare type GetFileParams = {
    fileKey: string;
    params?: Record<string, string | number | undefined>;
};

declare type GetImagesParams = {
    fileKey: string;
    nodeIds: string[];
    format?: 'jpg' | 'png' | 'svg' | 'pdf';
    scale?: number;
};

declare type GetNodeParams = {
    fileKey: string;
    nodeIds: string[];
    params?: Record<string, string | number>;
};

declare class HTTPClient {
    #private;
    plugins: HTTPClientPlugin[];
    baseAddress: string;
    constructor({ fetch, baseAddress }: HTTPClientConstructor);
    get headers(): Record<string, string>;
    addPlugin(plugin: HTTPClientPlugin): void;
    removePlugin(pluginName: string): void;
    withOptions(options?: Options): this;
    get<T>(url: string, options?: RequestOptions): Promise<T>;
    post<T>(url: string, body: unknown, options?: RequestOptions): Promise<T>;
    put<T>(url: string, body: unknown, options?: RequestOptions): Promise<T>;
    delete<T>(url: string, body: unknown, options?: RequestOptions): Promise<T>;
    patch<T>(url: string, body: unknown, options?: RequestOptions): Promise<T>;
}

declare type HTTPClientConstructor = {
    baseAddress: string;
    fetch?: typeof globalThis.fetch;
};

declare interface HTTPClientPlugin {
    name?: string;
    /**
     * Run a function before calling the API method.
     * If it returns a value different than undefined, the actual API function won't be called and instead that given value will be returned.
     */
    beforeApi?: ({ resource, api, args }: {
        resource: string;
        api: string;
        args: any[];
    }) => any;
}

export declare interface iFigmaRestApi {
    withOptions: (options?: Options) => iFigmaRestApi;
    baseAddress: string;
    token: string;
    files: Files;
    nodes: Nodes;
}

declare class Images implements API {
    #private;
    resourceName: string;
    constructor(figmaRestApi: FigmaRestApi);
    /**
     * Return the URL for the _layer_ images for the given nodes.
     * Note: Use the `file.images` API to get the _source_ images used on the node fills, which has better quality.
     */
    get({ fileKey, nodeIds, format, scale }: GetImagesParams): Promise<GetImagesResponse>;
}

declare class Nodes implements API {
    #private;
    resourceName: string;
    constructor(figmaRestApi: FigmaRestApi);
    get({ fileKey, nodeIds, params }: GetNodeParams): Promise<GetFileNodesResponse>;
}

declare type Options = {
    extraHeaders?: Record<string, string>;
    retry?: number;
    async?: AsyncRequestOptions;
    abortSignal?: AbortSignal;
    compress?: boolean;
    requestValidation?: boolean;
};

declare type RequestOptions = {
    overrideBaseAddress?: string;
    overrideDefaultHeaders?: Record<string, string>;
    skipBodyJsonStringify?: boolean;
};

declare type ResourceCache<T> = {
    entries: Map<string, CacheResponse<T>>;
    pendingRequests: Map<string, Promise<T>>;
};

export { }
