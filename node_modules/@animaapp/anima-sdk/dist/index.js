var oa = Object.defineProperty, la = Object.defineProperties;
var ca = Object.getOwnPropertyDescriptors;
var Dn = Object.getOwnPropertySymbols;
var da = Object.prototype.hasOwnProperty, ua = Object.prototype.propertyIsEnumerable;
var Mn = (e) => {
  throw TypeError(e);
}, Fn = Math.pow, Ln = (e, t, n) => t in e ? oa(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, d = (e, t) => {
  for (var n in t || (t = {}))
    da.call(t, n) && Ln(e, n, t[n]);
  if (Dn)
    for (var n of Dn(t))
      ua.call(t, n) && Ln(e, n, t[n]);
  return e;
}, b = (e, t) => la(e, ca(t));
var Vt = (e, t, n) => t.has(e) || Mn("Cannot " + n);
var C = (e, t, n) => (Vt(e, t, "read from private field"), n ? n.call(e) : t.get(e)), wt = (e, t, n) => t.has(e) ? Mn("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), Bt = (e, t, n, r) => (Vt(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n), De = (e, t, n) => (Vt(e, t, "access private method"), n);
var N = (e, t, n) => new Promise((r, a) => {
  var i = (l) => {
    try {
      o(n.next(l));
    } catch (c) {
      a(c);
    }
  }, s = (l) => {
    try {
      o(n.throw(l));
    } catch (c) {
      a(c);
    }
  }, o = (l) => l.done ? r(l.value) : Promise.resolve(l.value).then(i, s);
  o((n = n.apply(e, t)).next());
});
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
function Je(e) {
  let t = e.length;
  for (; --t >= 0; )
    e[t] = 0;
}
const fa = 0, vr = 1, ha = 2, _a = 3, pa = 258, On = 29, gt = 256, ct = gt + 1 + On, Fe = 30, Cn = 19, br = 2 * ct + 1, Ie = 15, Ht = 16, ma = 7, Nn = 256, wr = 16, xr = 17, kr = 18, tn = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
), At = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
), ga = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
), Sr = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), ya = 512, ue = new Array((ct + 2) * 2);
Je(ue);
const ot = new Array(Fe * 2);
Je(ot);
const dt = new Array(ya);
Je(dt);
const ut = new Array(pa - _a + 1);
Je(ut);
const In = new Array(On);
Je(In);
const Nt = new Array(Fe);
Je(Nt);
function Wt(e, t, n, r, a) {
  this.static_tree = e, this.extra_bits = t, this.extra_base = n, this.elems = r, this.max_length = a, this.has_stree = e && e.length;
}
let Tr, Ar, Er;
function qt(e, t) {
  this.dyn_tree = e, this.max_code = 0, this.stat_desc = t;
}
const Or = (e) => e < 256 ? dt[e] : dt[256 + (e >>> 7)], ft = (e, t) => {
  e.pending_buf[e.pending++] = t & 255, e.pending_buf[e.pending++] = t >>> 8 & 255;
}, B = (e, t, n) => {
  e.bi_valid > Ht - n ? (e.bi_buf |= t << e.bi_valid & 65535, ft(e, e.bi_buf), e.bi_buf = t >> Ht - e.bi_valid, e.bi_valid += n - Ht) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += n);
}, ae = (e, t, n) => {
  B(
    e,
    n[t * 2],
    n[t * 2 + 1]
    /*.Len*/
  );
}, Cr = (e, t) => {
  let n = 0;
  do
    n |= e & 1, e >>>= 1, n <<= 1;
  while (--t > 0);
  return n >>> 1;
}, va = (e) => {
  e.bi_valid === 16 ? (ft(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = e.bi_buf & 255, e.bi_buf >>= 8, e.bi_valid -= 8);
}, ba = (e, t) => {
  const n = t.dyn_tree, r = t.max_code, a = t.stat_desc.static_tree, i = t.stat_desc.has_stree, s = t.stat_desc.extra_bits, o = t.stat_desc.extra_base, l = t.stat_desc.max_length;
  let c, f, m, v, j, I, D = 0;
  for (v = 0; v <= Ie; v++)
    e.bl_count[v] = 0;
  for (n[e.heap[e.heap_max] * 2 + 1] = 0, c = e.heap_max + 1; c < br; c++)
    f = e.heap[c], v = n[n[f * 2 + 1] * 2 + 1] + 1, v > l && (v = l, D++), n[f * 2 + 1] = v, !(f > r) && (e.bl_count[v]++, j = 0, f >= o && (j = s[f - o]), I = n[f * 2], e.opt_len += I * (v + j), i && (e.static_len += I * (a[f * 2 + 1] + j)));
  if (D !== 0) {
    do {
      for (v = l - 1; e.bl_count[v] === 0; )
        v--;
      e.bl_count[v]--, e.bl_count[v + 1] += 2, e.bl_count[l]--, D -= 2;
    } while (D > 0);
    for (v = l; v !== 0; v--)
      for (f = e.bl_count[v]; f !== 0; )
        m = e.heap[--c], !(m > r) && (n[m * 2 + 1] !== v && (e.opt_len += (v - n[m * 2 + 1]) * n[m * 2], n[m * 2 + 1] = v), f--);
  }
}, Nr = (e, t, n) => {
  const r = new Array(Ie + 1);
  let a = 0, i, s;
  for (i = 1; i <= Ie; i++)
    a = a + n[i - 1] << 1, r[i] = a;
  for (s = 0; s <= t; s++) {
    let o = e[s * 2 + 1];
    o !== 0 && (e[s * 2] = Cr(r[o]++, o));
  }
}, wa = () => {
  let e, t, n, r, a;
  const i = new Array(Ie + 1);
  for (n = 0, r = 0; r < On - 1; r++)
    for (In[r] = n, e = 0; e < 1 << tn[r]; e++)
      ut[n++] = r;
  for (ut[n - 1] = r, a = 0, r = 0; r < 16; r++)
    for (Nt[r] = a, e = 0; e < 1 << At[r]; e++)
      dt[a++] = r;
  for (a >>= 7; r < Fe; r++)
    for (Nt[r] = a << 7, e = 0; e < 1 << At[r] - 7; e++)
      dt[256 + a++] = r;
  for (t = 0; t <= Ie; t++)
    i[t] = 0;
  for (e = 0; e <= 143; )
    ue[e * 2 + 1] = 8, e++, i[8]++;
  for (; e <= 255; )
    ue[e * 2 + 1] = 9, e++, i[9]++;
  for (; e <= 279; )
    ue[e * 2 + 1] = 7, e++, i[7]++;
  for (; e <= 287; )
    ue[e * 2 + 1] = 8, e++, i[8]++;
  for (Nr(ue, ct + 1, i), e = 0; e < Fe; e++)
    ot[e * 2 + 1] = 5, ot[e * 2] = Cr(e, 5);
  Tr = new Wt(ue, tn, gt + 1, ct, Ie), Ar = new Wt(ot, At, 0, Fe, Ie), Er = new Wt(new Array(0), ga, 0, Cn, ma);
}, Ir = (e) => {
  let t;
  for (t = 0; t < ct; t++)
    e.dyn_ltree[t * 2] = 0;
  for (t = 0; t < Fe; t++)
    e.dyn_dtree[t * 2] = 0;
  for (t = 0; t < Cn; t++)
    e.bl_tree[t * 2] = 0;
  e.dyn_ltree[Nn * 2] = 1, e.opt_len = e.static_len = 0, e.sym_next = e.matches = 0;
}, Rr = (e) => {
  e.bi_valid > 8 ? ft(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;
}, Pn = (e, t, n, r) => {
  const a = t * 2, i = n * 2;
  return e[a] < e[i] || e[a] === e[i] && r[t] <= r[n];
}, Kt = (e, t, n) => {
  const r = e.heap[n];
  let a = n << 1;
  for (; a <= e.heap_len && (a < e.heap_len && Pn(t, e.heap[a + 1], e.heap[a], e.depth) && a++, !Pn(t, r, e.heap[a], e.depth)); )
    e.heap[n] = e.heap[a], n = a, a <<= 1;
  e.heap[n] = r;
}, Un = (e, t, n) => {
  let r, a, i = 0, s, o;
  if (e.sym_next !== 0)
    do
      r = e.pending_buf[e.sym_buf + i++] & 255, r += (e.pending_buf[e.sym_buf + i++] & 255) << 8, a = e.pending_buf[e.sym_buf + i++], r === 0 ? ae(e, a, t) : (s = ut[a], ae(e, s + gt + 1, t), o = tn[s], o !== 0 && (a -= In[s], B(e, a, o)), r--, s = Or(r), ae(e, s, n), o = At[s], o !== 0 && (r -= Nt[s], B(e, r, o)));
    while (i < e.sym_next);
  ae(e, Nn, t);
}, nn = (e, t) => {
  const n = t.dyn_tree, r = t.stat_desc.static_tree, a = t.stat_desc.has_stree, i = t.stat_desc.elems;
  let s, o, l = -1, c;
  for (e.heap_len = 0, e.heap_max = br, s = 0; s < i; s++)
    n[s * 2] !== 0 ? (e.heap[++e.heap_len] = l = s, e.depth[s] = 0) : n[s * 2 + 1] = 0;
  for (; e.heap_len < 2; )
    c = e.heap[++e.heap_len] = l < 2 ? ++l : 0, n[c * 2] = 1, e.depth[c] = 0, e.opt_len--, a && (e.static_len -= r[c * 2 + 1]);
  for (t.max_code = l, s = e.heap_len >> 1; s >= 1; s--)
    Kt(e, n, s);
  c = i;
  do
    s = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[
      1
      /*SMALLEST*/
    ] = e.heap[e.heap_len--], Kt(
      e,
      n,
      1
      /*SMALLEST*/
    ), o = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[--e.heap_max] = s, e.heap[--e.heap_max] = o, n[c * 2] = n[s * 2] + n[o * 2], e.depth[c] = (e.depth[s] >= e.depth[o] ? e.depth[s] : e.depth[o]) + 1, n[s * 2 + 1] = n[o * 2 + 1] = c, e.heap[
      1
      /*SMALLEST*/
    ] = c++, Kt(
      e,
      n,
      1
      /*SMALLEST*/
    );
  while (e.heap_len >= 2);
  e.heap[--e.heap_max] = e.heap[
    1
    /*SMALLEST*/
  ], ba(e, t), Nr(n, l, e.bl_count);
}, Vn = (e, t, n) => {
  let r, a = -1, i, s = t[1], o = 0, l = 7, c = 4;
  for (s === 0 && (l = 138, c = 3), t[(n + 1) * 2 + 1] = 65535, r = 0; r <= n; r++)
    i = s, s = t[(r + 1) * 2 + 1], !(++o < l && i === s) && (o < c ? e.bl_tree[i * 2] += o : i !== 0 ? (i !== a && e.bl_tree[i * 2]++, e.bl_tree[wr * 2]++) : o <= 10 ? e.bl_tree[xr * 2]++ : e.bl_tree[kr * 2]++, o = 0, a = i, s === 0 ? (l = 138, c = 3) : i === s ? (l = 6, c = 3) : (l = 7, c = 4));
}, Bn = (e, t, n) => {
  let r, a = -1, i, s = t[1], o = 0, l = 7, c = 4;
  for (s === 0 && (l = 138, c = 3), r = 0; r <= n; r++)
    if (i = s, s = t[(r + 1) * 2 + 1], !(++o < l && i === s)) {
      if (o < c)
        do
          ae(e, i, e.bl_tree);
        while (--o !== 0);
      else i !== 0 ? (i !== a && (ae(e, i, e.bl_tree), o--), ae(e, wr, e.bl_tree), B(e, o - 3, 2)) : o <= 10 ? (ae(e, xr, e.bl_tree), B(e, o - 3, 3)) : (ae(e, kr, e.bl_tree), B(e, o - 11, 7));
      o = 0, a = i, s === 0 ? (l = 138, c = 3) : i === s ? (l = 6, c = 3) : (l = 7, c = 4);
    }
}, xa = (e) => {
  let t;
  for (Vn(e, e.dyn_ltree, e.l_desc.max_code), Vn(e, e.dyn_dtree, e.d_desc.max_code), nn(e, e.bl_desc), t = Cn - 1; t >= 3 && e.bl_tree[Sr[t] * 2 + 1] === 0; t--)
    ;
  return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
}, ka = (e, t, n, r) => {
  let a;
  for (B(e, t - 257, 5), B(e, n - 1, 5), B(e, r - 4, 4), a = 0; a < r; a++)
    B(e, e.bl_tree[Sr[a] * 2 + 1], 3);
  Bn(e, e.dyn_ltree, t - 1), Bn(e, e.dyn_dtree, n - 1);
}, Sa = (e) => {
  let t = 4093624447, n;
  for (n = 0; n <= 31; n++, t >>>= 1)
    if (t & 1 && e.dyn_ltree[n * 2] !== 0)
      return 0;
  if (e.dyn_ltree[18] !== 0 || e.dyn_ltree[20] !== 0 || e.dyn_ltree[26] !== 0)
    return 1;
  for (n = 32; n < gt; n++)
    if (e.dyn_ltree[n * 2] !== 0)
      return 1;
  return 0;
};
let Hn = !1;
const Ta = (e) => {
  Hn || (wa(), Hn = !0), e.l_desc = new qt(e.dyn_ltree, Tr), e.d_desc = new qt(e.dyn_dtree, Ar), e.bl_desc = new qt(e.bl_tree, Er), e.bi_buf = 0, e.bi_valid = 0, Ir(e);
}, Zr = (e, t, n, r) => {
  B(e, (fa << 1) + (r ? 1 : 0), 3), Rr(e), ft(e, n), ft(e, ~n), n && e.pending_buf.set(e.window.subarray(t, t + n), e.pending), e.pending += n;
}, Aa = (e) => {
  B(e, vr << 1, 3), ae(e, Nn, ue), va(e);
}, Ea = (e, t, n, r) => {
  let a, i, s = 0;
  e.level > 0 ? (e.strm.data_type === 2 && (e.strm.data_type = Sa(e)), nn(e, e.l_desc), nn(e, e.d_desc), s = xa(e), a = e.opt_len + 3 + 7 >>> 3, i = e.static_len + 3 + 7 >>> 3, i <= a && (a = i)) : a = i = n + 5, n + 4 <= a && t !== -1 ? Zr(e, t, n, r) : e.strategy === 4 || i === a ? (B(e, (vr << 1) + (r ? 1 : 0), 3), Un(e, ue, ot)) : (B(e, (ha << 1) + (r ? 1 : 0), 3), ka(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, s + 1), Un(e, e.dyn_ltree, e.dyn_dtree)), Ir(e), r && Rr(e);
}, Oa = (e, t, n) => (e.pending_buf[e.sym_buf + e.sym_next++] = t, e.pending_buf[e.sym_buf + e.sym_next++] = t >> 8, e.pending_buf[e.sym_buf + e.sym_next++] = n, t === 0 ? e.dyn_ltree[n * 2]++ : (e.matches++, t--, e.dyn_ltree[(ut[n] + gt + 1) * 2]++, e.dyn_dtree[Or(t) * 2]++), e.sym_next === e.sym_end);
var Ca = Ta, Na = Zr, Ia = Ea, Ra = Oa, Za = Aa, za = {
  _tr_init: Ca,
  _tr_stored_block: Na,
  _tr_flush_block: Ia,
  _tr_tally: Ra,
  _tr_align: Za
};
const ja = (e, t, n, r) => {
  let a = e & 65535 | 0, i = e >>> 16 & 65535 | 0, s = 0;
  for (; n !== 0; ) {
    s = n > 2e3 ? 2e3 : n, n -= s;
    do
      a = a + t[r++] | 0, i = i + a | 0;
    while (--s);
    a %= 65521, i %= 65521;
  }
  return a | i << 16 | 0;
};
var zr = ja;
const $a = () => {
  let e, t = [];
  for (var n = 0; n < 256; n++) {
    e = n;
    for (var r = 0; r < 8; r++)
      e = e & 1 ? 3988292384 ^ e >>> 1 : e >>> 1;
    t[n] = e;
  }
  return t;
}, Da = new Uint32Array($a()), La = (e, t, n, r) => {
  const a = Da, i = r + n;
  e ^= -1;
  for (let s = r; s < i; s++)
    e = e >>> 8 ^ a[(e ^ t[s]) & 255];
  return e ^ -1;
};
var ge = La, It = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, jr = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_BUF_ERROR: -5,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init: Ma, _tr_stored_block: rn, _tr_flush_block: Fa, _tr_tally: xe, _tr_align: Pa } = za, {
  Z_NO_FLUSH: ke,
  Z_PARTIAL_FLUSH: Ua,
  Z_FULL_FLUSH: Va,
  Z_FINISH: X,
  Z_BLOCK: Wn,
  Z_OK: L,
  Z_STREAM_END: qn,
  Z_STREAM_ERROR: ie,
  Z_DATA_ERROR: Ba,
  Z_BUF_ERROR: Jt,
  Z_DEFAULT_COMPRESSION: Ha,
  Z_FILTERED: Wa,
  Z_HUFFMAN_ONLY: xt,
  Z_RLE: qa,
  Z_FIXED: Ka,
  Z_DEFAULT_STRATEGY: Ja,
  Z_UNKNOWN: Xa,
  Z_DEFLATED: Mt
} = jr, Ga = 9, Ya = 15, Qa = 8, ei = 29, ti = 256, an = ti + 1 + ei, ni = 30, ri = 19, ai = 2 * an + 1, ii = 15, x = 3, we = 258, se = we + x + 1, si = 32, Pe = 42, Rn = 57, sn = 69, on = 73, ln = 91, cn = 103, Re = 113, et = 666, P = 1, Xe = 2, ze = 3, Ge = 4, oi = 3, Ze = (e, t) => (e.msg = It[t], t), Kn = (e) => e * 2 - (e > 4 ? 9 : 0), be = (e) => {
  let t = e.length;
  for (; --t >= 0; )
    e[t] = 0;
}, li = (e) => {
  let t, n, r, a = e.w_size;
  t = e.hash_size, r = t;
  do
    n = e.head[--r], e.head[r] = n >= a ? n - a : 0;
  while (--t);
  t = a, r = t;
  do
    n = e.prev[--r], e.prev[r] = n >= a ? n - a : 0;
  while (--t);
};
let ci = (e, t, n) => (t << e.hash_shift ^ n) & e.hash_mask, Se = ci;
const q = (e) => {
  const t = e.state;
  let n = t.pending;
  n > e.avail_out && (n = e.avail_out), n !== 0 && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + n), e.next_out), e.next_out += n, t.pending_out += n, e.total_out += n, e.avail_out -= n, t.pending -= n, t.pending === 0 && (t.pending_out = 0));
}, J = (e, t) => {
  Fa(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, q(e.strm);
}, A = (e, t) => {
  e.pending_buf[e.pending++] = t;
}, Ye = (e, t) => {
  e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = t & 255;
}, dn = (e, t, n, r) => {
  let a = e.avail_in;
  return a > r && (a = r), a === 0 ? 0 : (e.avail_in -= a, t.set(e.input.subarray(e.next_in, e.next_in + a), n), e.state.wrap === 1 ? e.adler = zr(e.adler, t, a, n) : e.state.wrap === 2 && (e.adler = ge(e.adler, t, a, n)), e.next_in += a, e.total_in += a, a);
}, $r = (e, t) => {
  let n = e.max_chain_length, r = e.strstart, a, i, s = e.prev_length, o = e.nice_match;
  const l = e.strstart > e.w_size - se ? e.strstart - (e.w_size - se) : 0, c = e.window, f = e.w_mask, m = e.prev, v = e.strstart + we;
  let j = c[r + s - 1], I = c[r + s];
  e.prev_length >= e.good_match && (n >>= 2), o > e.lookahead && (o = e.lookahead);
  do
    if (a = t, !(c[a + s] !== I || c[a + s - 1] !== j || c[a] !== c[r] || c[++a] !== c[r + 1])) {
      r += 2, a++;
      do
        ;
      while (c[++r] === c[++a] && c[++r] === c[++a] && c[++r] === c[++a] && c[++r] === c[++a] && c[++r] === c[++a] && c[++r] === c[++a] && c[++r] === c[++a] && c[++r] === c[++a] && r < v);
      if (i = we - (v - r), r = v - we, i > s) {
        if (e.match_start = t, s = i, i >= o)
          break;
        j = c[r + s - 1], I = c[r + s];
      }
    }
  while ((t = m[t & f]) > l && --n !== 0);
  return s <= e.lookahead ? s : e.lookahead;
}, Ue = (e) => {
  const t = e.w_size;
  let n, r, a;
  do {
    if (r = e.window_size - e.lookahead - e.strstart, e.strstart >= t + (t - se) && (e.window.set(e.window.subarray(t, t + t - r), 0), e.match_start -= t, e.strstart -= t, e.block_start -= t, e.insert > e.strstart && (e.insert = e.strstart), li(e), r += t), e.strm.avail_in === 0)
      break;
    if (n = dn(e.strm, e.window, e.strstart + e.lookahead, r), e.lookahead += n, e.lookahead + e.insert >= x)
      for (a = e.strstart - e.insert, e.ins_h = e.window[a], e.ins_h = Se(e, e.ins_h, e.window[a + 1]); e.insert && (e.ins_h = Se(e, e.ins_h, e.window[a + x - 1]), e.prev[a & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = a, a++, e.insert--, !(e.lookahead + e.insert < x)); )
        ;
  } while (e.lookahead < se && e.strm.avail_in !== 0);
}, Dr = (e, t) => {
  let n = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5, r, a, i, s = 0, o = e.strm.avail_in;
  do {
    if (r = 65535, i = e.bi_valid + 42 >> 3, e.strm.avail_out < i || (i = e.strm.avail_out - i, a = e.strstart - e.block_start, r > a + e.strm.avail_in && (r = a + e.strm.avail_in), r > i && (r = i), r < n && (r === 0 && t !== X || t === ke || r !== a + e.strm.avail_in)))
      break;
    s = t === X && r === a + e.strm.avail_in ? 1 : 0, rn(e, 0, 0, s), e.pending_buf[e.pending - 4] = r, e.pending_buf[e.pending - 3] = r >> 8, e.pending_buf[e.pending - 2] = ~r, e.pending_buf[e.pending - 1] = ~r >> 8, q(e.strm), a && (a > r && (a = r), e.strm.output.set(e.window.subarray(e.block_start, e.block_start + a), e.strm.next_out), e.strm.next_out += a, e.strm.avail_out -= a, e.strm.total_out += a, e.block_start += a, r -= a), r && (dn(e.strm, e.strm.output, e.strm.next_out, r), e.strm.next_out += r, e.strm.avail_out -= r, e.strm.total_out += r);
  } while (s === 0);
  return o -= e.strm.avail_in, o && (o >= e.w_size ? (e.matches = 2, e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0), e.strstart = e.w_size, e.insert = e.strstart) : (e.window_size - e.strstart <= o && (e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, e.insert > e.strstart && (e.insert = e.strstart)), e.window.set(e.strm.input.subarray(e.strm.next_in - o, e.strm.next_in), e.strstart), e.strstart += o, e.insert += o > e.w_size - e.insert ? e.w_size - e.insert : o), e.block_start = e.strstart), e.high_water < e.strstart && (e.high_water = e.strstart), s ? Ge : t !== ke && t !== X && e.strm.avail_in === 0 && e.strstart === e.block_start ? Xe : (i = e.window_size - e.strstart, e.strm.avail_in > i && e.block_start >= e.w_size && (e.block_start -= e.w_size, e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, i += e.w_size, e.insert > e.strstart && (e.insert = e.strstart)), i > e.strm.avail_in && (i = e.strm.avail_in), i && (dn(e.strm, e.window, e.strstart, i), e.strstart += i, e.insert += i > e.w_size - e.insert ? e.w_size - e.insert : i), e.high_water < e.strstart && (e.high_water = e.strstart), i = e.bi_valid + 42 >> 3, i = e.pending_buf_size - i > 65535 ? 65535 : e.pending_buf_size - i, n = i > e.w_size ? e.w_size : i, a = e.strstart - e.block_start, (a >= n || (a || t === X) && t !== ke && e.strm.avail_in === 0 && a <= i) && (r = a > i ? i : a, s = t === X && e.strm.avail_in === 0 && r === a ? 1 : 0, rn(e, e.block_start, r, s), e.block_start += r, q(e.strm)), s ? ze : P);
}, Xt = (e, t) => {
  let n, r;
  for (; ; ) {
    if (e.lookahead < se) {
      if (Ue(e), e.lookahead < se && t === ke)
        return P;
      if (e.lookahead === 0)
        break;
    }
    if (n = 0, e.lookahead >= x && (e.ins_h = Se(e, e.ins_h, e.window[e.strstart + x - 1]), n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), n !== 0 && e.strstart - n <= e.w_size - se && (e.match_length = $r(e, n)), e.match_length >= x)
      if (r = xe(e, e.strstart - e.match_start, e.match_length - x), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= x) {
        e.match_length--;
        do
          e.strstart++, e.ins_h = Se(e, e.ins_h, e.window[e.strstart + x - 1]), n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;
        while (--e.match_length !== 0);
        e.strstart++;
      } else
        e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = Se(e, e.ins_h, e.window[e.strstart + 1]);
    else
      r = xe(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
    if (r && (J(e, !1), e.strm.avail_out === 0))
      return P;
  }
  return e.insert = e.strstart < x - 1 ? e.strstart : x - 1, t === X ? (J(e, !0), e.strm.avail_out === 0 ? ze : Ge) : e.sym_next && (J(e, !1), e.strm.avail_out === 0) ? P : Xe;
}, Le = (e, t) => {
  let n, r, a;
  for (; ; ) {
    if (e.lookahead < se) {
      if (Ue(e), e.lookahead < se && t === ke)
        return P;
      if (e.lookahead === 0)
        break;
    }
    if (n = 0, e.lookahead >= x && (e.ins_h = Se(e, e.ins_h, e.window[e.strstart + x - 1]), n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = x - 1, n !== 0 && e.prev_length < e.max_lazy_match && e.strstart - n <= e.w_size - se && (e.match_length = $r(e, n), e.match_length <= 5 && (e.strategy === Wa || e.match_length === x && e.strstart - e.match_start > 4096) && (e.match_length = x - 1)), e.prev_length >= x && e.match_length <= e.prev_length) {
      a = e.strstart + e.lookahead - x, r = xe(e, e.strstart - 1 - e.prev_match, e.prev_length - x), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
      do
        ++e.strstart <= a && (e.ins_h = Se(e, e.ins_h, e.window[e.strstart + x - 1]), n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);
      while (--e.prev_length !== 0);
      if (e.match_available = 0, e.match_length = x - 1, e.strstart++, r && (J(e, !1), e.strm.avail_out === 0))
        return P;
    } else if (e.match_available) {
      if (r = xe(e, 0, e.window[e.strstart - 1]), r && J(e, !1), e.strstart++, e.lookahead--, e.strm.avail_out === 0)
        return P;
    } else
      e.match_available = 1, e.strstart++, e.lookahead--;
  }
  return e.match_available && (r = xe(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < x - 1 ? e.strstart : x - 1, t === X ? (J(e, !0), e.strm.avail_out === 0 ? ze : Ge) : e.sym_next && (J(e, !1), e.strm.avail_out === 0) ? P : Xe;
}, di = (e, t) => {
  let n, r, a, i;
  const s = e.window;
  for (; ; ) {
    if (e.lookahead <= we) {
      if (Ue(e), e.lookahead <= we && t === ke)
        return P;
      if (e.lookahead === 0)
        break;
    }
    if (e.match_length = 0, e.lookahead >= x && e.strstart > 0 && (a = e.strstart - 1, r = s[a], r === s[++a] && r === s[++a] && r === s[++a])) {
      i = e.strstart + we;
      do
        ;
      while (r === s[++a] && r === s[++a] && r === s[++a] && r === s[++a] && r === s[++a] && r === s[++a] && r === s[++a] && r === s[++a] && a < i);
      e.match_length = we - (i - a), e.match_length > e.lookahead && (e.match_length = e.lookahead);
    }
    if (e.match_length >= x ? (n = xe(e, 1, e.match_length - x), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (n = xe(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), n && (J(e, !1), e.strm.avail_out === 0))
      return P;
  }
  return e.insert = 0, t === X ? (J(e, !0), e.strm.avail_out === 0 ? ze : Ge) : e.sym_next && (J(e, !1), e.strm.avail_out === 0) ? P : Xe;
}, ui = (e, t) => {
  let n;
  for (; ; ) {
    if (e.lookahead === 0 && (Ue(e), e.lookahead === 0)) {
      if (t === ke)
        return P;
      break;
    }
    if (e.match_length = 0, n = xe(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, n && (J(e, !1), e.strm.avail_out === 0))
      return P;
  }
  return e.insert = 0, t === X ? (J(e, !0), e.strm.avail_out === 0 ? ze : Ge) : e.sym_next && (J(e, !1), e.strm.avail_out === 0) ? P : Xe;
};
function ee(e, t, n, r, a) {
  this.good_length = e, this.max_lazy = t, this.nice_length = n, this.max_chain = r, this.func = a;
}
const tt = [
  /*      good lazy nice chain */
  new ee(0, 0, 0, 0, Dr),
  /* 0 store only */
  new ee(4, 4, 8, 4, Xt),
  /* 1 max speed, no lazy matches */
  new ee(4, 5, 16, 8, Xt),
  /* 2 */
  new ee(4, 6, 32, 32, Xt),
  /* 3 */
  new ee(4, 4, 16, 16, Le),
  /* 4 lazy matches */
  new ee(8, 16, 32, 32, Le),
  /* 5 */
  new ee(8, 16, 128, 128, Le),
  /* 6 */
  new ee(8, 32, 128, 256, Le),
  /* 7 */
  new ee(32, 128, 258, 1024, Le),
  /* 8 */
  new ee(32, 258, 258, 4096, Le)
  /* 9 max compression */
], fi = (e) => {
  e.window_size = 2 * e.w_size, be(e.head), e.max_lazy_match = tt[e.level].max_lazy, e.good_match = tt[e.level].good_length, e.nice_match = tt[e.level].nice_length, e.max_chain_length = tt[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = x - 1, e.match_available = 0, e.ins_h = 0;
};
function hi() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Mt, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(ai * 2), this.dyn_dtree = new Uint16Array((2 * ni + 1) * 2), this.bl_tree = new Uint16Array((2 * ri + 1) * 2), be(this.dyn_ltree), be(this.dyn_dtree), be(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(ii + 1), this.heap = new Uint16Array(2 * an + 1), be(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * an + 1), be(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
const yt = (e) => {
  if (!e)
    return 1;
  const t = e.state;
  return !t || t.strm !== e || t.status !== Pe && //#ifdef GZIP
  t.status !== Rn && //#endif
  t.status !== sn && t.status !== on && t.status !== ln && t.status !== cn && t.status !== Re && t.status !== et ? 1 : 0;
}, Lr = (e) => {
  if (yt(e))
    return Ze(e, ie);
  e.total_in = e.total_out = 0, e.data_type = Xa;
  const t = e.state;
  return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = //#ifdef GZIP
  t.wrap === 2 ? Rn : (
    //#endif
    t.wrap ? Pe : Re
  ), e.adler = t.wrap === 2 ? 0 : 1, t.last_flush = -2, Ma(t), L;
}, Mr = (e) => {
  const t = Lr(e);
  return t === L && fi(e.state), t;
}, _i = (e, t) => yt(e) || e.state.wrap !== 2 ? ie : (e.state.gzhead = t, L), Fr = (e, t, n, r, a, i) => {
  if (!e)
    return ie;
  let s = 1;
  if (t === Ha && (t = 6), r < 0 ? (s = 0, r = -r) : r > 15 && (s = 2, r -= 16), a < 1 || a > Ga || n !== Mt || r < 8 || r > 15 || t < 0 || t > 9 || i < 0 || i > Ka || r === 8 && s !== 1)
    return Ze(e, ie);
  r === 8 && (r = 9);
  const o = new hi();
  return e.state = o, o.strm = e, o.status = Pe, o.wrap = s, o.gzhead = null, o.w_bits = r, o.w_size = 1 << o.w_bits, o.w_mask = o.w_size - 1, o.hash_bits = a + 7, o.hash_size = 1 << o.hash_bits, o.hash_mask = o.hash_size - 1, o.hash_shift = ~~((o.hash_bits + x - 1) / x), o.window = new Uint8Array(o.w_size * 2), o.head = new Uint16Array(o.hash_size), o.prev = new Uint16Array(o.w_size), o.lit_bufsize = 1 << a + 6, o.pending_buf_size = o.lit_bufsize * 4, o.pending_buf = new Uint8Array(o.pending_buf_size), o.sym_buf = o.lit_bufsize, o.sym_end = (o.lit_bufsize - 1) * 3, o.level = t, o.strategy = i, o.method = n, Mr(e);
}, pi = (e, t) => Fr(e, t, Mt, Ya, Qa, Ja), mi = (e, t) => {
  if (yt(e) || t > Wn || t < 0)
    return e ? Ze(e, ie) : ie;
  const n = e.state;
  if (!e.output || e.avail_in !== 0 && !e.input || n.status === et && t !== X)
    return Ze(e, e.avail_out === 0 ? Jt : ie);
  const r = n.last_flush;
  if (n.last_flush = t, n.pending !== 0) {
    if (q(e), e.avail_out === 0)
      return n.last_flush = -1, L;
  } else if (e.avail_in === 0 && Kn(t) <= Kn(r) && t !== X)
    return Ze(e, Jt);
  if (n.status === et && e.avail_in !== 0)
    return Ze(e, Jt);
  if (n.status === Pe && n.wrap === 0 && (n.status = Re), n.status === Pe) {
    let a = Mt + (n.w_bits - 8 << 4) << 8, i = -1;
    if (n.strategy >= xt || n.level < 2 ? i = 0 : n.level < 6 ? i = 1 : n.level === 6 ? i = 2 : i = 3, a |= i << 6, n.strstart !== 0 && (a |= si), a += 31 - a % 31, Ye(n, a), n.strstart !== 0 && (Ye(n, e.adler >>> 16), Ye(n, e.adler & 65535)), e.adler = 1, n.status = Re, q(e), n.pending !== 0)
      return n.last_flush = -1, L;
  }
  if (n.status === Rn) {
    if (e.adler = 0, A(n, 31), A(n, 139), A(n, 8), n.gzhead)
      A(
        n,
        (n.gzhead.text ? 1 : 0) + (n.gzhead.hcrc ? 2 : 0) + (n.gzhead.extra ? 4 : 0) + (n.gzhead.name ? 8 : 0) + (n.gzhead.comment ? 16 : 0)
      ), A(n, n.gzhead.time & 255), A(n, n.gzhead.time >> 8 & 255), A(n, n.gzhead.time >> 16 & 255), A(n, n.gzhead.time >> 24 & 255), A(n, n.level === 9 ? 2 : n.strategy >= xt || n.level < 2 ? 4 : 0), A(n, n.gzhead.os & 255), n.gzhead.extra && n.gzhead.extra.length && (A(n, n.gzhead.extra.length & 255), A(n, n.gzhead.extra.length >> 8 & 255)), n.gzhead.hcrc && (e.adler = ge(e.adler, n.pending_buf, n.pending, 0)), n.gzindex = 0, n.status = sn;
    else if (A(n, 0), A(n, 0), A(n, 0), A(n, 0), A(n, 0), A(n, n.level === 9 ? 2 : n.strategy >= xt || n.level < 2 ? 4 : 0), A(n, oi), n.status = Re, q(e), n.pending !== 0)
      return n.last_flush = -1, L;
  }
  if (n.status === sn) {
    if (n.gzhead.extra) {
      let a = n.pending, i = (n.gzhead.extra.length & 65535) - n.gzindex;
      for (; n.pending + i > n.pending_buf_size; ) {
        let o = n.pending_buf_size - n.pending;
        if (n.pending_buf.set(n.gzhead.extra.subarray(n.gzindex, n.gzindex + o), n.pending), n.pending = n.pending_buf_size, n.gzhead.hcrc && n.pending > a && (e.adler = ge(e.adler, n.pending_buf, n.pending - a, a)), n.gzindex += o, q(e), n.pending !== 0)
          return n.last_flush = -1, L;
        a = 0, i -= o;
      }
      let s = new Uint8Array(n.gzhead.extra);
      n.pending_buf.set(s.subarray(n.gzindex, n.gzindex + i), n.pending), n.pending += i, n.gzhead.hcrc && n.pending > a && (e.adler = ge(e.adler, n.pending_buf, n.pending - a, a)), n.gzindex = 0;
    }
    n.status = on;
  }
  if (n.status === on) {
    if (n.gzhead.name) {
      let a = n.pending, i;
      do {
        if (n.pending === n.pending_buf_size) {
          if (n.gzhead.hcrc && n.pending > a && (e.adler = ge(e.adler, n.pending_buf, n.pending - a, a)), q(e), n.pending !== 0)
            return n.last_flush = -1, L;
          a = 0;
        }
        n.gzindex < n.gzhead.name.length ? i = n.gzhead.name.charCodeAt(n.gzindex++) & 255 : i = 0, A(n, i);
      } while (i !== 0);
      n.gzhead.hcrc && n.pending > a && (e.adler = ge(e.adler, n.pending_buf, n.pending - a, a)), n.gzindex = 0;
    }
    n.status = ln;
  }
  if (n.status === ln) {
    if (n.gzhead.comment) {
      let a = n.pending, i;
      do {
        if (n.pending === n.pending_buf_size) {
          if (n.gzhead.hcrc && n.pending > a && (e.adler = ge(e.adler, n.pending_buf, n.pending - a, a)), q(e), n.pending !== 0)
            return n.last_flush = -1, L;
          a = 0;
        }
        n.gzindex < n.gzhead.comment.length ? i = n.gzhead.comment.charCodeAt(n.gzindex++) & 255 : i = 0, A(n, i);
      } while (i !== 0);
      n.gzhead.hcrc && n.pending > a && (e.adler = ge(e.adler, n.pending_buf, n.pending - a, a));
    }
    n.status = cn;
  }
  if (n.status === cn) {
    if (n.gzhead.hcrc) {
      if (n.pending + 2 > n.pending_buf_size && (q(e), n.pending !== 0))
        return n.last_flush = -1, L;
      A(n, e.adler & 255), A(n, e.adler >> 8 & 255), e.adler = 0;
    }
    if (n.status = Re, q(e), n.pending !== 0)
      return n.last_flush = -1, L;
  }
  if (e.avail_in !== 0 || n.lookahead !== 0 || t !== ke && n.status !== et) {
    let a = n.level === 0 ? Dr(n, t) : n.strategy === xt ? ui(n, t) : n.strategy === qa ? di(n, t) : tt[n.level].func(n, t);
    if ((a === ze || a === Ge) && (n.status = et), a === P || a === ze)
      return e.avail_out === 0 && (n.last_flush = -1), L;
    if (a === Xe && (t === Ua ? Pa(n) : t !== Wn && (rn(n, 0, 0, !1), t === Va && (be(n.head), n.lookahead === 0 && (n.strstart = 0, n.block_start = 0, n.insert = 0))), q(e), e.avail_out === 0))
      return n.last_flush = -1, L;
  }
  return t !== X ? L : n.wrap <= 0 ? qn : (n.wrap === 2 ? (A(n, e.adler & 255), A(n, e.adler >> 8 & 255), A(n, e.adler >> 16 & 255), A(n, e.adler >> 24 & 255), A(n, e.total_in & 255), A(n, e.total_in >> 8 & 255), A(n, e.total_in >> 16 & 255), A(n, e.total_in >> 24 & 255)) : (Ye(n, e.adler >>> 16), Ye(n, e.adler & 65535)), q(e), n.wrap > 0 && (n.wrap = -n.wrap), n.pending !== 0 ? L : qn);
}, gi = (e) => {
  if (yt(e))
    return ie;
  const t = e.state.status;
  return e.state = null, t === Re ? Ze(e, Ba) : L;
}, yi = (e, t) => {
  let n = t.length;
  if (yt(e))
    return ie;
  const r = e.state, a = r.wrap;
  if (a === 2 || a === 1 && r.status !== Pe || r.lookahead)
    return ie;
  if (a === 1 && (e.adler = zr(e.adler, t, n, 0)), r.wrap = 0, n >= r.w_size) {
    a === 0 && (be(r.head), r.strstart = 0, r.block_start = 0, r.insert = 0);
    let l = new Uint8Array(r.w_size);
    l.set(t.subarray(n - r.w_size, n), 0), t = l, n = r.w_size;
  }
  const i = e.avail_in, s = e.next_in, o = e.input;
  for (e.avail_in = n, e.next_in = 0, e.input = t, Ue(r); r.lookahead >= x; ) {
    let l = r.strstart, c = r.lookahead - (x - 1);
    do
      r.ins_h = Se(r, r.ins_h, r.window[l + x - 1]), r.prev[l & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = l, l++;
    while (--c);
    r.strstart = l, r.lookahead = x - 1, Ue(r);
  }
  return r.strstart += r.lookahead, r.block_start = r.strstart, r.insert = r.lookahead, r.lookahead = 0, r.match_length = r.prev_length = x - 1, r.match_available = 0, e.next_in = s, e.input = o, e.avail_in = i, r.wrap = a, L;
};
var vi = pi, bi = Fr, wi = Mr, xi = Lr, ki = _i, Si = mi, Ti = gi, Ai = yi, Ei = "pako deflate (from Nodeca project)", lt = {
  deflateInit: vi,
  deflateInit2: bi,
  deflateReset: wi,
  deflateResetKeep: xi,
  deflateSetHeader: ki,
  deflate: Si,
  deflateEnd: Ti,
  deflateSetDictionary: Ai,
  deflateInfo: Ei
};
const Oi = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
var Ci = function(e) {
  const t = Array.prototype.slice.call(arguments, 1);
  for (; t.length; ) {
    const n = t.shift();
    if (n) {
      if (typeof n != "object")
        throw new TypeError(n + "must be non-object");
      for (const r in n)
        Oi(n, r) && (e[r] = n[r]);
    }
  }
  return e;
}, Ni = (e) => {
  let t = 0;
  for (let r = 0, a = e.length; r < a; r++)
    t += e[r].length;
  const n = new Uint8Array(t);
  for (let r = 0, a = 0, i = e.length; r < i; r++) {
    let s = e[r];
    n.set(s, a), a += s.length;
  }
  return n;
}, Pr = {
  assign: Ci,
  flattenChunks: Ni
};
let Ur = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (e) {
  Ur = !1;
}
const ht = new Uint8Array(256);
for (let e = 0; e < 256; e++)
  ht[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
ht[254] = ht[254] = 1;
var Ii = (e) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(e);
  let t, n, r, a, i, s = e.length, o = 0;
  for (a = 0; a < s; a++)
    n = e.charCodeAt(a), (n & 64512) === 55296 && a + 1 < s && (r = e.charCodeAt(a + 1), (r & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (r - 56320), a++)), o += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;
  for (t = new Uint8Array(o), i = 0, a = 0; i < o; a++)
    n = e.charCodeAt(a), (n & 64512) === 55296 && a + 1 < s && (r = e.charCodeAt(a + 1), (r & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (r - 56320), a++)), n < 128 ? t[i++] = n : n < 2048 ? (t[i++] = 192 | n >>> 6, t[i++] = 128 | n & 63) : n < 65536 ? (t[i++] = 224 | n >>> 12, t[i++] = 128 | n >>> 6 & 63, t[i++] = 128 | n & 63) : (t[i++] = 240 | n >>> 18, t[i++] = 128 | n >>> 12 & 63, t[i++] = 128 | n >>> 6 & 63, t[i++] = 128 | n & 63);
  return t;
};
const Ri = (e, t) => {
  if (t < 65534 && e.subarray && Ur)
    return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
  let n = "";
  for (let r = 0; r < t; r++)
    n += String.fromCharCode(e[r]);
  return n;
};
var Zi = (e, t) => {
  const n = t || e.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(e.subarray(0, t));
  let r, a;
  const i = new Array(n * 2);
  for (a = 0, r = 0; r < n; ) {
    let s = e[r++];
    if (s < 128) {
      i[a++] = s;
      continue;
    }
    let o = ht[s];
    if (o > 4) {
      i[a++] = 65533, r += o - 1;
      continue;
    }
    for (s &= o === 2 ? 31 : o === 3 ? 15 : 7; o > 1 && r < n; )
      s = s << 6 | e[r++] & 63, o--;
    if (o > 1) {
      i[a++] = 65533;
      continue;
    }
    s < 65536 ? i[a++] = s : (s -= 65536, i[a++] = 55296 | s >> 10 & 1023, i[a++] = 56320 | s & 1023);
  }
  return Ri(i, a);
}, zi = (e, t) => {
  t = t || e.length, t > e.length && (t = e.length);
  let n = t - 1;
  for (; n >= 0 && (e[n] & 192) === 128; )
    n--;
  return n < 0 || n === 0 ? t : n + ht[e[n]] > t ? n : t;
}, Vr = {
  string2buf: Ii,
  buf2string: Zi,
  utf8border: zi
};
function ji() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var $i = ji;
const Br = Object.prototype.toString, {
  Z_NO_FLUSH: Di,
  Z_SYNC_FLUSH: Li,
  Z_FULL_FLUSH: Mi,
  Z_FINISH: Fi,
  Z_OK: Rt,
  Z_STREAM_END: Pi,
  Z_DEFAULT_COMPRESSION: Ui,
  Z_DEFAULT_STRATEGY: Vi,
  Z_DEFLATED: Bi
} = jr;
function Ft(e) {
  this.options = Pr.assign({
    level: Ui,
    method: Bi,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Vi
  }, e || {});
  let t = this.options;
  t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new $i(), this.strm.avail_out = 0;
  let n = lt.deflateInit2(
    this.strm,
    t.level,
    t.method,
    t.windowBits,
    t.memLevel,
    t.strategy
  );
  if (n !== Rt)
    throw new Error(It[n]);
  if (t.header && lt.deflateSetHeader(this.strm, t.header), t.dictionary) {
    let r;
    if (typeof t.dictionary == "string" ? r = Vr.string2buf(t.dictionary) : Br.call(t.dictionary) === "[object ArrayBuffer]" ? r = new Uint8Array(t.dictionary) : r = t.dictionary, n = lt.deflateSetDictionary(this.strm, r), n !== Rt)
      throw new Error(It[n]);
    this._dict_set = !0;
  }
}
Ft.prototype.push = function(e, t) {
  const n = this.strm, r = this.options.chunkSize;
  let a, i;
  if (this.ended)
    return !1;
  for (t === ~~t ? i = t : i = t === !0 ? Fi : Di, typeof e == "string" ? n.input = Vr.string2buf(e) : Br.call(e) === "[object ArrayBuffer]" ? n.input = new Uint8Array(e) : n.input = e, n.next_in = 0, n.avail_in = n.input.length; ; ) {
    if (n.avail_out === 0 && (n.output = new Uint8Array(r), n.next_out = 0, n.avail_out = r), (i === Li || i === Mi) && n.avail_out <= 6) {
      this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
      continue;
    }
    if (a = lt.deflate(n, i), a === Pi)
      return n.next_out > 0 && this.onData(n.output.subarray(0, n.next_out)), a = lt.deflateEnd(this.strm), this.onEnd(a), this.ended = !0, a === Rt;
    if (n.avail_out === 0) {
      this.onData(n.output);
      continue;
    }
    if (i > 0 && n.next_out > 0) {
      this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
      continue;
    }
    if (n.avail_in === 0) break;
  }
  return !0;
};
Ft.prototype.onData = function(e) {
  this.chunks.push(e);
};
Ft.prototype.onEnd = function(e) {
  e === Rt && (this.result = Pr.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function Hi(e, t) {
  const n = new Ft(t);
  if (n.push(e, !0), n.err)
    throw n.msg || It[n.err];
  return n.result;
}
function Wi(e, t) {
  return t = t || {}, t.gzip = !0, Hi(e, t);
}
var qi = Wi, Ki = {
  gzip: qi
};
const { gzip: Ji } = Ki;
var Xi = Ji;
class Oe extends Error {
  constructor({
    name: t,
    reason: n,
    status: r,
    detail: a
  }) {
    super(), this.name = t, this.message = n, this.detail = a, this.status = r;
  }
}
const Hr = "Figma Token Issue";
class Gi extends Error {
  constructor({
    fileKey: t,
    reason: n,
    cause: r
  }) {
    super(Hr), this.fileKey = t, this.reason = n, this.cause = r;
  }
}
const Wr = "Rate Limit Exceeded";
class Yi extends Error {
  constructor({ fileKey: t, cause: n }) {
    super(Wr), this.fileKey = t, this.cause = n;
  }
}
const qr = "Request Too Large";
class Qi extends Error {
  constructor({ fileKey: t, cause: n }) {
    super(qr), this.fileKey = t, this.cause = n;
  }
}
const Kr = "Not Found";
class es extends Error {
  constructor({ fileKey: t, cause: n }) {
    super(Kr), this.fileKey = t, this.cause = n;
  }
}
const ts = (e) => e.message === Kr, Jr = "Unknown Figma API Exception";
class ns extends Error {
  constructor({ fileKey: t, cause: n }) {
    super(Jr), this.name = "UnknownFigmaApiException", this.fileKey = t, this.cause = n;
  }
}
const Bo = (e) => e.message === Jr, rs = (e) => e.message === Wr, as = (e) => [Hr, ...[
  "Invalid Figma token",
  "Figma token expired"
]].includes(
  e.message
), is = (e) => e.message === qr, Xr = (e, t) => {
  var r;
  if (((r = e == null ? void 0 : e.cause) == null ? void 0 : r.message) === "Fetch Error") {
    const { err: a, status: i } = e.cause.body;
    if (i === 403)
      return new Gi({
        fileKey: t,
        reason: a,
        cause: e
      });
    if (i === 429)
      return new Yi({ fileKey: t, cause: e });
    if (i === 404)
      return new es({ fileKey: t, cause: e });
    if (i === 400 && a.includes("Request too large"))
      return new Qi({ fileKey: t, cause: e });
  }
  return new ns({ fileKey: t, cause: e });
}, Ho = (e) => ts(e) ? "NotFound" : rs(e) ? "RateLimitExceeded" : as(e) ? "FigmaTokenIssue" : is(e) ? "RequestTooLarge" : "UnknownFigmaApiException";
var ss = Object.defineProperty, os = Object.defineProperties, ls = Object.getOwnPropertyDescriptors, Jn = Object.getOwnPropertySymbols, cs = Object.prototype.hasOwnProperty, ds = Object.prototype.propertyIsEnumerable, Xn = (e, t) => (t = Symbol[e]) ? t : Symbol.for("Symbol." + e), Gr = (e) => {
  throw TypeError(e);
}, Gn = (e, t, n) => t in e ? ss(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, K = (e, t) => {
  for (var n in t || (t = {}))
    cs.call(t, n) && Gn(e, n, t[n]);
  if (Jn)
    for (var n of Jn(t))
      ds.call(t, n) && Gn(e, n, t[n]);
  return e;
}, Zn = (e, t) => os(e, ls(t)), zn = (e, t, n) => t.has(e) || Gr("Cannot " + n), E = (e, t, n) => (zn(e, t, "read from private field"), n ? n.call(e) : t.get(e)), G = (e, t, n) => t.has(e) ? Gr("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), M = (e, t, n, r) => (zn(e, t, "write to private field"), t.set(e, n), n), re = (e, t, n) => (zn(e, t, "access private method"), n), z = (e, t, n) => new Promise((r, a) => {
  var i = (l) => {
    try {
      o(n.next(l));
    } catch (c) {
      a(c);
    }
  }, s = (l) => {
    try {
      o(n.throw(l));
    } catch (c) {
      a(c);
    }
  }, o = (l) => l.done ? r(l.value) : Promise.resolve(l.value).then(i, s);
  o((n = n.apply(e, t)).next());
}), us = (e, t, n) => (t = e[Xn("asyncIterator")]) ? t.call(e) : (e = e[Xn("iterator")](), t = {}, n = (r, a) => (a = e[r]) && (t[r] = (i) => new Promise((s, o, l) => (i = a.call(e, i), l = i.done, Promise.resolve(i.value).then((c) => s({ value: c, done: l }), o)))), n("next"), n("return"), t), fs = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function hs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var un = { exports: {} }, _s = un.exports, Yn;
function ps() {
  return Yn || (Yn = 1, (function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(_s, function() {
      var n = typeof Promise == "function", r = typeof self == "object" ? self : fs, a = typeof Symbol != "undefined", i = typeof Map != "undefined", s = typeof Set != "undefined", o = typeof WeakMap != "undefined", l = typeof WeakSet != "undefined", c = typeof DataView != "undefined", f = a && typeof Symbol.iterator != "undefined", m = a && typeof Symbol.toStringTag != "undefined", v = s && typeof Set.prototype.entries == "function", j = i && typeof Map.prototype.entries == "function", I = v && Object.getPrototypeOf((/* @__PURE__ */ new Set()).entries()), D = j && Object.getPrototypeOf((/* @__PURE__ */ new Map()).entries()), ce = f && typeof Array.prototype[Symbol.iterator] == "function", Ee = ce && Object.getPrototypeOf([][Symbol.iterator]()), pe = f && typeof String.prototype[Symbol.iterator] == "function", H = pe && Object.getPrototypeOf(""[Symbol.iterator]()), me = 8, vt = -1;
      function bt(R) {
        var W = typeof R;
        if (W !== "object")
          return W;
        if (R === null)
          return "null";
        if (R === r)
          return "global";
        if (Array.isArray(R) && (m === !1 || !(Symbol.toStringTag in R)))
          return "Array";
        if (typeof window == "object" && window !== null) {
          if (typeof window.location == "object" && R === window.location)
            return "Location";
          if (typeof window.document == "object" && R === window.document)
            return "Document";
          if (typeof window.navigator == "object") {
            if (typeof window.navigator.mimeTypes == "object" && R === window.navigator.mimeTypes)
              return "MimeTypeArray";
            if (typeof window.navigator.plugins == "object" && R === window.navigator.plugins)
              return "PluginArray";
          }
          if ((typeof window.HTMLElement == "function" || typeof window.HTMLElement == "object") && R instanceof window.HTMLElement) {
            if (R.tagName === "BLOCKQUOTE")
              return "HTMLQuoteElement";
            if (R.tagName === "TD")
              return "HTMLTableDataCellElement";
            if (R.tagName === "TH")
              return "HTMLTableHeaderCellElement";
          }
        }
        var $e = m && R[Symbol.toStringTag];
        if (typeof $e == "string")
          return $e;
        var $ = Object.getPrototypeOf(R);
        return $ === RegExp.prototype ? "RegExp" : $ === Date.prototype ? "Date" : n && $ === Promise.prototype ? "Promise" : s && $ === Set.prototype ? "Set" : i && $ === Map.prototype ? "Map" : l && $ === WeakSet.prototype ? "WeakSet" : o && $ === WeakMap.prototype ? "WeakMap" : c && $ === DataView.prototype ? "DataView" : i && $ === D ? "Map Iterator" : s && $ === I ? "Set Iterator" : ce && $ === Ee ? "Array Iterator" : pe && $ === H ? "String Iterator" : $ === null ? "Object" : Object.prototype.toString.call(R).slice(me, vt);
      }
      return bt;
    });
  })(un)), un.exports;
}
var ms = ps();
const gs = /* @__PURE__ */ hs(ms), jn = typeof Buffer != "undefined", ys = jn && typeof Buffer.from != "undefined", vs = jn ? (
  /**
   * is value is Buffer?
   *
   * @param {*} value
   * @return {boolean}
   */
  (function(e) {
    return Buffer.isBuffer(e);
  })
) : (
  /**
   * return false
   *
   * NOTE: for Buffer unsupported
   *
   * @return {boolean}
   */
  (function() {
    return !1;
  })
), bs = ys ? (
  /**
   * copy Buffer
   *
   * @param {Buffer} value
   * @return {Buffer}
   */
  (function(e) {
    return Buffer.from(e);
  })
) : jn ? (
  /**
   * copy Buffer
   *
   * NOTE: for old node.js
   *
   * @param {Buffer} value
   * @return {Buffer}
   */
  (function(e) {
    return new Buffer(e);
  })
) : (
  /**
   * shallow copy
   *
   * NOTE: for Buffer unsupported
   *
   * @param {*}
   * @return {*}
   */
  (function(e) {
    return e;
  })
);
function Ve(e) {
  return vs(e) ? "Buffer" : gs(e);
}
const ws = /* @__PURE__ */ new Set([
  "Arguments",
  "Array",
  "Map",
  "Object",
  "Set"
]);
function xs(e, t, n = null) {
  switch (n || Ve(e)) {
    case "Arguments":
    case "Array":
    case "Object":
      return e[t];
    case "Map":
      return e.get(t);
    case "Set":
      return t;
  }
}
function fn(e) {
  return ws.has(e);
}
function Qn(e, t, n, r = null) {
  switch (r || Ve(e)) {
    case "Arguments":
    case "Array":
    case "Object":
      e[t] = n;
      break;
    case "Map":
      e.set(t, n);
      break;
    case "Set":
      e.add(n);
      break;
  }
  return e;
}
const ks = typeof globalThis != "undefined" && globalThis !== null && globalThis.Object === Object && globalThis, Ss = typeof global != "undefined" && global !== null && global.Object === Object && global, Ts = typeof self != "undefined" && self !== null && self.Object === Object && self, Gt = ks || Ss || Ts || Function("return this")();
function As(e) {
  return e.slice(0);
}
function Es(e) {
  return new Boolean(e.valueOf());
}
function Os(e) {
  return new DataView(e.buffer);
}
function Cs(e) {
  return bs(e);
}
function Ns(e) {
  return new Date(e.getTime());
}
function Is(e) {
  return new Number(e);
}
function Rs(e) {
  return new RegExp(e.source, e.flags);
}
function Zs(e) {
  return new String(e);
}
function de(e, t) {
  return Gt[t].from ? Gt[t].from(e) : new Gt[t](e);
}
function F(e) {
  return e;
}
function er() {
  return [];
}
function zs() {
  return /* @__PURE__ */ new Map();
}
function js() {
  return {};
}
function $s() {
  return /* @__PURE__ */ new Set();
}
const Ds = /* @__PURE__ */ new Map([
  // deep copy
  ["ArrayBuffer", As],
  ["Boolean", Es],
  ["Buffer", Cs],
  ["DataView", Os],
  ["Date", Ns],
  ["Number", Is],
  ["RegExp", Rs],
  ["String", Zs],
  // typed arrays
  // TODO: pass bound function
  ["Float32Array", de],
  ["Float64Array", de],
  ["Int16Array", de],
  ["Int32Array", de],
  ["Int8Array", de],
  ["Uint16Array", de],
  ["Uint32Array", de],
  ["Uint8Array", de],
  ["Uint8ClampedArray", de],
  // shallow copy
  ["Array Iterator", F],
  ["Map Iterator", F],
  ["Promise", F],
  ["Set Iterator", F],
  ["String Iterator", F],
  ["function", F],
  ["global", F],
  // NOTE: WeakMap and WeakSet cannot get entries
  ["WeakMap", F],
  ["WeakSet", F],
  // primitives
  ["boolean", F],
  ["null", F],
  ["number", F],
  ["string", F],
  ["symbol", F],
  ["undefined", F],
  // collections
  // NOTE: return empty value, because recursively copy later.
  ["Arguments", er],
  ["Array", er],
  ["Map", zs],
  ["Object", js],
  ["Set", $s]
  // NOTE: type-detect returns following types
  // 'Location'
  // 'Document'
  // 'MimeTypeArray'
  // 'PluginArray'
  // 'HTMLQuoteElement'
  // 'HTMLTableDataCellElement'
  // 'HTMLTableHeaderCellElement'
  // TODO: is type-detect never return 'object'?
  // 'object'
]);
function Ls() {
}
function hn(e, t = null, n = Ls) {
  arguments.length === 2 && typeof t == "function" && (n = t, t = null);
  const r = t || Ve(e), a = Ds.get(r);
  if (r === "Object") {
    const i = n(e, r);
    if (i !== void 0)
      return i;
  }
  return a ? a(e, r) : e;
}
function Qe(e, t = {}) {
  typeof t == "function" && (t = {
    customizer: t
  });
  const {
    // TODO: before/after customizer
    customizer: n
    // TODO: max depth
    // depth = Infinity,
  } = t, r = Ve(e);
  if (!fn(r))
    return _n(e, null, null, null);
  const a = hn(e, r, n), i = new WeakMap([[e, a]]), s = new WeakSet([e]);
  return _n(e, a, i, s);
}
function _n(e, t, n, r, a) {
  const i = Ve(e), s = hn(e, i);
  if (!fn(i))
    return s;
  let o;
  switch (i) {
    case "Arguments":
    case "Array":
      o = Object.keys(e);
      break;
    case "Object":
      o = Object.keys(e), o.push(...Object.getOwnPropertySymbols(e));
      break;
    case "Map":
    case "Set":
      o = e.keys();
      break;
  }
  for (let l of o) {
    const c = xs(e, l, i);
    if (r.has(c))
      Qn(t, l, n.get(c), i);
    else {
      const f = Ve(c), m = hn(c, f);
      fn(f) && (n.set(c, m), r.add(c)), Qn(
        t,
        l,
        _n(
          c,
          m,
          n,
          r
        ),
        i
      );
    }
  }
  return t;
}
const Ms = (e) => new Promise((t) => setTimeout(t, e));
var Et, Ce, Ot, pn, Yr;
class Fs {
  constructor({ maxAttempts: t = 3, func: n }) {
    G(this, pn), G(this, Et), G(this, Ce), G(this, Ot), M(this, Et, t), M(this, Ot, n), M(this, Ce, 0);
  }
  run() {
    return z(this, null, function* () {
      try {
        return yield E(this, Ot).call(this);
      } catch (t) {
        if (M(this, Ce, E(this, Ce) + 1), E(this, Ce) > E(this, Et))
          throw console.error("Max attempts reached"), t;
        const n = re(this, pn, Yr).call(this);
        return yield Ms(n), yield this.run();
      }
    });
  }
}
Et = /* @__PURE__ */ new WeakMap(), Ce = /* @__PURE__ */ new WeakMap(), Ot = /* @__PURE__ */ new WeakMap(), pn = /* @__PURE__ */ new WeakSet(), Yr = function() {
  return E(this, Ce) * 1e3 * 1.5;
};
function Ps() {
  return typeof CompressionStream != "undefined";
}
function Us(e) {
  return z(this, null, function* () {
    const t = new Blob([e]).stream().pipeThrough(new CompressionStream("gzip")), n = [];
    try {
      for (var r = us(t), a, i, s; a = !(i = yield r.next()).done; a = !1) {
        const o = i.value;
        n.push(o);
      }
    } catch (o) {
      s = [o];
    } finally {
      try {
        a && (i = r.return) && (yield i.call(r));
      } finally {
        if (s)
          throw s[0];
      }
    }
    return yield Vs(n);
  });
}
function Vs(e) {
  return z(this, null, function* () {
    const t = yield new Blob(e).arrayBuffer();
    return new Uint8Array(t);
  });
}
class Bs extends Error {
  constructor({ resource: t, api: n, args: r, cause: a }) {
    if (super(`API Error on resource "${t}" at api "${n}"`), this.causeProperties = {}, this.name = "API Error", this.resource = t, this.api = n, this.cause = a, this.args = r, a instanceof Error)
      for (const [s, o] of Object.entries(a))
        if (typeof Headers != "undefined" && o instanceof Headers) {
          const l = {};
          o.forEach((c, f) => {
            l[f] = c;
          }), this.causeProperties[s] = l;
        } else
          this.causeProperties[s] = o;
    const i = this.causeProperties.body;
    i && typeof i == "object" && "code" in i && (this.code = i.code);
  }
}
class tr extends Error {
  constructor({
    url: t,
    method: n,
    statusCode: r,
    requestHeaders: a,
    responseHeaders: i,
    body: s
  }) {
    if (super("Fetch Error"), this.name = "Fetch Error", this.url = t, this.method = n, this.statusNumber = r, this.requestHeaders = a, this.responseHeaders = i, s)
      try {
        const o = JSON.parse(s);
        this.body = o;
      } catch (o) {
        this.body = s;
      }
  }
}
class nt extends Error {
  constructor(t = {}) {
    const { canceled: n = !1 } = t;
    super("Abort Error"), this.name = "Abort Error", this.canceled = n;
  }
}
class Hs extends Error {
  constructor(t) {
    super(`Async API Error: ${JSON.stringify(t)}`), this.name = "Async API Error", this.body = t;
  }
}
class Yt extends Error {
  constructor(t) {
    super(t), this.name = "Request Validation Error";
  }
}
function Qr() {
  return Array.from(
    { length: 32 },
    () => Math.floor(Math.random() * 256).toString(16).padStart(2, "0")
  ).join("");
}
function mn() {
  return Math.floor(Date.now() / 1e3).toString();
}
const Ws = 300 * 1e3, qs = 1 * 1e3;
var Ne, V, te, gn, yn, rt;
class Ks {
  constructor({ fetch: t = globalThis.fetch.bind(globalThis), baseAddress: n }) {
    G(this, te), G(this, Ne), G(this, V), this.baseAddress = n, M(this, Ne, t), M(this, V, {}), this.plugins = [];
  }
  get headers() {
    throw new Error("Missing implementation");
  }
  addPlugin(t) {
    this.plugins.push(t);
  }
  removePlugin(t) {
    this.plugins = this.plugins.filter((n) => n.name !== t);
  }
  withOptions(t = {}) {
    return M(this, V, t), this;
  }
  get(t) {
    return z(this, arguments, function* (n, r = {}) {
      const { overrideBaseAddress: a, overrideDefaultHeaders: i } = r, s = a != null ? a : this.baseAddress;
      let o = i != null ? i : this.headers;
      const l = Qe(E(this, V));
      return M(this, V, {}), l.extraHeaders && (o = K(K({}, o), l.extraHeaders)), l.requestValidation && (o = Zn(K({}, o), { "X-Request-Nonce": Qr(), "X-Request-Timestamp": mn() })), l.async ? yield re(this, te, yn).call(this, `${s}${n}`, l.async, { headers: o }) : yield re(this, te, gn).call(this, `${s}${n}`, l, { headers: o });
    });
  }
  post(t, n) {
    return z(this, arguments, function* (r, a, i = {}) {
      const s = Qe(E(this, V));
      return M(this, V, {}), re(this, te, rt).call(this, r, "POST", a, i, s);
    });
  }
  put(t, n) {
    return z(this, arguments, function* (r, a, i = {}) {
      const s = Qe(E(this, V));
      return M(this, V, {}), re(this, te, rt).call(this, r, "PUT", a, i, s);
    });
  }
  delete(t, n) {
    return z(this, arguments, function* (r, a, i = {}) {
      const s = Qe(E(this, V));
      return M(this, V, {}), re(this, te, rt).call(this, r, "DELETE", a, i, s);
    });
  }
  patch(t, n) {
    return z(this, arguments, function* (r, a, i = {}) {
      const s = Qe(E(this, V));
      return M(this, V, {}), re(this, te, rt).call(this, r, "PATCH", a, i, s);
    });
  }
}
Ne = /* @__PURE__ */ new WeakMap(), V = /* @__PURE__ */ new WeakMap(), te = /* @__PURE__ */ new WeakSet(), gn = function(e, t, n) {
  return z(this, null, function* () {
    const r = () => z(this, null, function* () {
      var l, c;
      try {
        return yield E(this, Ne).call(this, e, K(K({}, n), t.abortSignal && { signal: t.abortSignal }));
      } catch (f) {
        throw f instanceof Error && f.name === "AbortError" ? new nt({ canceled: (c = (l = t.abortSignal) == null ? void 0 : l.aborted) != null ? c : !1 }) : f;
      }
    }), { headers: a } = n != null ? n : {}, i = (l, c) => {
      var f, m;
      return ((f = l == null ? void 0 : l.headers) == null ? void 0 : f.get(c)) || ((m = l == null ? void 0 : l.headersObject) == null ? void 0 : m[c]) || "";
    }, s = (l) => z(this, null, function* () {
      var c;
      if (!l.ok) {
        const m = yield l.text().catch();
        throw new tr({
          url: e,
          method: (c = n == null ? void 0 : n.method) != null ? c : "GET",
          statusCode: l.status,
          requestHeaders: a,
          responseHeaders: l.headers,
          body: m
        });
      }
      if (t.requestValidation && process.env.UI_TESTS !== !0)
        try {
          const m = i(l, "x-response-nonce"), v = a == null ? void 0 : a["X-Request-Nonce"];
          if (!m || m !== v)
            throw new Yt("Response nonce mismatch");
          const j = Number(i(l, "x-response-timestamp")), I = Number(mn()), D = 3600 * 24;
          if (isNaN(j) || Math.abs(I - j) > D)
            throw new Yt("Invalid response timestamp");
        } catch (m) {
          const v = m instanceof Error ? m.message : "Request validation failed";
          throw new Yt(v);
        }
      let f = yield l.text();
      try {
        f = JSON.parse(f);
      } catch (m) {
      }
      return f;
    });
    if (t.retry) {
      const l = yield new Fs({
        maxAttempts: t.retry,
        func: r
      }).run();
      return yield s(l);
    }
    const o = yield r();
    return yield s(o);
  });
}, yn = function(e, t, n) {
  return z(this, null, function* () {
    var r, a;
    const {
      onProgress: i,
      abortSignal: s,
      pollingInterval: o = () => qs,
      maxTimeout: l = Ws
    } = t, c = `${e}/async`, f = `${e}/async/job`;
    let m;
    try {
      m = yield E(this, Ne).call(this, c, K(K({}, n), s && { signal: s }));
    } catch (I) {
      throw I instanceof Error && I.name === "AbortError" ? new nt({ canceled: (r = s == null ? void 0 : s.aborted) != null ? r : !1 }) : I;
    }
    if (!m.ok) {
      const I = yield m.text().catch();
      throw new tr({
        url: e,
        method: (a = n == null ? void 0 : n.method) != null ? a : "GET",
        statusCode: m.status,
        requestHeaders: this.headers,
        responseHeaders: m.headers,
        body: I
      });
    }
    const v = yield m.json(), { job_id: j } = v;
    if (!j)
      throw new Error("Job ID not found in response");
    return new Promise((I, D) => z(this, null, function* () {
      const ce = setTimeout(() => {
        D(new Error("Job timed out"));
      }, l), Ee = (pe = 0) => z(this, null, function* () {
        if (s != null && s.aborted) {
          clearTimeout(ce), E(this, Ne).call(this, `${f}/${j}/cancel`, { method: "POST", headers: this.headers }).then(() => {
            D(new nt({ canceled: !0 }));
          }).catch((H) => {
            D(new nt({ canceled: !1 }));
          });
          return;
        }
        try {
          const H = yield (yield E(this, Ne).call(this, `${f}/${j}`, { headers: this.headers })).json();
          if (H.status === "success") {
            clearTimeout(ce);
            const me = H.response_json;
            I(me);
          } else if (H.status === "failed")
            clearTimeout(ce), D(new Hs(H.response_json));
          else {
            i && i(H.response_json);
            const me = o(pe);
            setTimeout(() => Ee(pe + 1), me);
          }
        } catch (H) {
          D(H);
        }
      });
      Ee();
    }));
  });
}, rt = function(e, t, n, r, a) {
  return z(this, null, function* () {
    const { overrideBaseAddress: i, overrideDefaultHeaders: s } = r, o = i != null ? i : this.baseAddress;
    let l = s != null ? s : this.headers;
    a.extraHeaders && (l = K(K({}, l), a.extraHeaders)), a.requestValidation && (l = Zn(K({}, l), { "X-Request-Nonce": Qr(), "X-Request-Timestamp": mn() }));
    let c = n;
    return typeof FormData != "undefined" && n instanceof FormData ? delete l["Content-Type"] : (c = r.skipBodyJsonStringify ? n : JSON.stringify(n), a.compress && Ps() && (l["Content-Encoding"] = "gzip", c = yield Us(c))), a.async ? yield re(this, te, yn).call(this, `${o}${e}`, a.async, {
      method: t,
      headers: l,
      body: c
    }) : yield re(this, te, gn).call(this, `${o}${e}`, a, { method: t, headers: l, body: c });
  });
};
const nr = (e, t, n, r) => e instanceof nt ? e : new Bs({ resource: t, api: String(n), args: r, cause: e }), Qt = (e, t) => new Proxy(t, {
  get(n, r) {
    return (...a) => {
      var i;
      for (const o of e.plugins) {
        const l = (i = o.beforeApi) == null ? void 0 : i.call(o, { resource: n.resourceName, api: r, args: a });
        if (l !== void 0)
          return l;
      }
      let s;
      try {
        s = n[r](...a);
      } catch (o) {
        throw nr(o, n.resourceName, r, a);
      }
      return s instanceof Promise ? s.catch((o) => {
        throw nr(o, n.resourceName, r, a);
      }) : s;
    };
  }
});
var at;
class Js {
  constructor(t) {
    G(this, at), this.resourceName = "Files", M(this, at, t);
  }
  get(t) {
    return z(this, arguments, function* ({ fileKey: n, params: r = {} }) {
      const a = new URLSearchParams(K({
        plugin_data: "857346721138427857"
      }, r)).toString(), i = `v1/files/${n}?${a}`;
      return yield E(this, at).get(i);
    });
  }
  getImageFills(t) {
    return z(this, arguments, function* ({ fileKey: n }) {
      var r, a;
      const i = `v1/files/${n}/images`;
      return (a = (r = (yield E(this, at).get(i)).meta) == null ? void 0 : r.images) != null ? a : {};
    });
  }
}
at = /* @__PURE__ */ new WeakMap();
const Xs = (e, t, n) => {
  const r = t.sort();
  return `${e}-${r.join("-")}-${n}`;
}, Gs = (e) => e ? e.ts > Date.now() - 1e3 * 30 : !1;
var ne, vn, ea;
class Ys {
  constructor(t) {
    G(this, vn), G(this, ne), this.resourceName = "Images", M(this, ne, t);
  }
  /**
   * Return the URL for the _layer_ images for the given nodes.
   * Note: Use the `file.images` API to get the _source_ images used on the node fills, which has better quality.
   */
  get(t) {
    return z(this, arguments, function* ({ fileKey: n, nodeIds: r, format: a = "jpg", scale: i }) {
      const s = Xs(n, r, a), o = E(this, ne).cache.images.entries.get(s);
      if (Gs(o))
        return o.result;
      o && E(this, ne).cache.images.entries.delete(s);
      const l = E(this, ne).cache.images.pendingRequests.get(s);
      if (l)
        return l;
      const c = re(this, vn, ea).call(this, s, n, r, a, i);
      E(this, ne).cache.images.pendingRequests.set(s, c);
      try {
        return yield c;
      } finally {
        E(this, ne).cache.images.pendingRequests.delete(s);
      }
    });
  }
}
ne = /* @__PURE__ */ new WeakMap(), vn = /* @__PURE__ */ new WeakSet(), ea = function(e, t, n, r, a) {
  return z(this, null, function* () {
    const i = yield E(this, ne).get(
      `v1/images/${t}?ids=${n}&format=${r}${a ? `&scale=${a}` : ""}`
    );
    return E(this, ne).cache.images.entries.set(e, {
      result: i,
      ts: Date.now()
    }), i;
  });
};
var Ct;
class Qs {
  constructor(t) {
    G(this, Ct), this.resourceName = "Nodes", M(this, Ct, t);
  }
  get(t) {
    return z(this, arguments, function* ({ fileKey: n, nodeIds: r, params: a = {} }) {
      const i = Zn(K({}, a), {
        ids: r.join(",")
      }), s = new URLSearchParams(K({
        plugin_data: "857346721138427857"
      }, i)).toString(), o = `v1/files/${n}/nodes?${s}`;
      return yield E(this, Ct).get(o);
    });
  }
}
Ct = /* @__PURE__ */ new WeakMap();
var ye;
class ta extends Ks {
  constructor({
    baseAddress: t = "https://api.figma.com/",
    fetch: n = globalThis.fetch.bind(globalThis)
  } = {}) {
    super({ fetch: n, baseAddress: t }), G(this, ye, ""), this.cache = {
      images: {
        entries: /* @__PURE__ */ new Map(),
        pendingRequests: /* @__PURE__ */ new Map()
      }
    }, this.files = Qt(this, new Js(this)), this.nodes = Qt(this, new Qs(this)), this.images = Qt(this, new Ys(this));
  }
  set token(t) {
    if (!t.startsWith("figd_") && !t.startsWith("figu_"))
      throw new Error("Invalid Figma access token");
    M(this, ye, t);
  }
  get token() {
    return E(this, ye);
  }
  get headers() {
    const t = {
      "Content-Type": "application/json"
    };
    return E(this, ye).startsWith("figd_") ? t["X-FIGMA-TOKEN"] = E(this, ye) : E(this, ye).startsWith("figu_") && (t.Authorization = `Bearer ${E(this, ye)}`), t;
  }
}
ye = /* @__PURE__ */ new WeakMap();
const eo = (i) => N(null, [i], function* ({
  fileKey: e,
  authToken: t,
  figmaRestApi: n = new ta(),
  params: r = {},
  signal: a
}) {
  t && (n.token = t);
  try {
    return yield n.withOptions({
      abortSignal: a
    }).files.get({
      fileKey: e,
      params: r
    });
  } catch (s) {
    throw s instanceof Error && s.name === "AbortError" ? s : (console.error(s), Xr(s, e));
  }
}), Wo = (s) => N(null, [s], function* ({
  fileKey: e,
  authToken: t,
  nodeIds: n,
  figmaRestApi: r = new ta(),
  params: a = {},
  signal: i
}) {
  t && (r.token = t);
  try {
    return (yield r.withOptions({
      abortSignal: i
    }).nodes.get({
      fileKey: e,
      nodeIds: n,
      params: d({}, a)
    })).nodes;
  } catch (o) {
    throw o instanceof Error && o.name === "AbortError" ? o : Xr(o, e);
  }
}), na = (e, t) => {
  if (e.id === t)
    return e;
  if ("children" in e)
    for (const n of e.children) {
      const r = na(n, t);
      if (r)
        return r;
    }
  return null;
};
var T;
(function(e) {
  e.assertEqual = (a) => {
  };
  function t(a) {
  }
  e.assertIs = t;
  function n(a) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (a) => {
    const i = {};
    for (const s of a)
      i[s] = s;
    return i;
  }, e.getValidEnumValues = (a) => {
    const i = e.objectKeys(a).filter((o) => typeof a[a[o]] != "number"), s = {};
    for (const o of i)
      s[o] = a[o];
    return e.objectValues(s);
  }, e.objectValues = (a) => e.objectKeys(a).map(function(i) {
    return a[i];
  }), e.objectKeys = typeof Object.keys == "function" ? (a) => Object.keys(a) : (a) => {
    const i = [];
    for (const s in a)
      Object.prototype.hasOwnProperty.call(a, s) && i.push(s);
    return i;
  }, e.find = (a, i) => {
    for (const s of a)
      if (i(s))
        return s;
  }, e.isInteger = typeof Number.isInteger == "function" ? (a) => Number.isInteger(a) : (a) => typeof a == "number" && Number.isFinite(a) && Math.floor(a) === a;
  function r(a, i = " | ") {
    return a.map((s) => typeof s == "string" ? `'${s}'` : s).join(i);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (a, i) => typeof i == "bigint" ? i.toString() : i;
})(T || (T = {}));
var rr;
(function(e) {
  e.mergeShapes = (t, n) => d(d({}, t), n);
})(rr || (rr = {}));
const _ = T.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), ve = (e) => {
  switch (typeof e) {
    case "undefined":
      return _.undefined;
    case "string":
      return _.string;
    case "number":
      return Number.isNaN(e) ? _.nan : _.number;
    case "boolean":
      return _.boolean;
    case "function":
      return _.function;
    case "bigint":
      return _.bigint;
    case "symbol":
      return _.symbol;
    case "object":
      return Array.isArray(e) ? _.array : e === null ? _.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? _.promise : typeof Map != "undefined" && e instanceof Map ? _.map : typeof Set != "undefined" && e instanceof Set ? _.set : typeof Date != "undefined" && e instanceof Date ? _.date : _.object;
    default:
      return _.unknown;
  }
}, u = T.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class _e extends Error {
  get errors() {
    return this.issues;
  }
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  format(t) {
    const n = t || function(i) {
      return i.message;
    }, r = { _errors: [] }, a = (i) => {
      for (const s of i.issues)
        if (s.code === "invalid_union")
          s.unionErrors.map(a);
        else if (s.code === "invalid_return_type")
          a(s.returnTypeError);
        else if (s.code === "invalid_arguments")
          a(s.argumentsError);
        else if (s.path.length === 0)
          r._errors.push(n(s));
        else {
          let o = r, l = 0;
          for (; l < s.path.length; ) {
            const c = s.path[l];
            l === s.path.length - 1 ? (o[c] = o[c] || { _errors: [] }, o[c]._errors.push(n(s))) : o[c] = o[c] || { _errors: [] }, o = o[c], l++;
          }
        }
    };
    return a(this), r;
  }
  static assert(t) {
    if (!(t instanceof _e))
      throw new Error(`Not a ZodError: ${t}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, T.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = {}, r = [];
    for (const a of this.issues)
      if (a.path.length > 0) {
        const i = a.path[0];
        n[i] = n[i] || [], n[i].push(t(a));
      } else
        r.push(t(a));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
_e.create = (e) => new _e(e);
const bn = (e, t) => {
  let n;
  switch (e.code) {
    case u.invalid_type:
      e.received === _.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
      break;
    case u.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, T.jsonStringifyReplacer)}`;
      break;
    case u.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${T.joinValues(e.keys, ", ")}`;
      break;
    case u.invalid_union:
      n = "Invalid input";
      break;
    case u.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${T.joinValues(e.options)}`;
      break;
    case u.invalid_enum_value:
      n = `Invalid enum value. Expected ${T.joinValues(e.options)}, received '${e.received}'`;
      break;
    case u.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case u.invalid_return_type:
      n = "Invalid function return type";
      break;
    case u.invalid_date:
      n = "Invalid date";
      break;
    case u.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : T.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
      break;
    case u.too_small:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "bigint" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
      break;
    case u.too_big:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
      break;
    case u.custom:
      n = "Invalid input";
      break;
    case u.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case u.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case u.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = t.defaultError, T.assertNever(e);
  }
  return { message: n };
};
let to = bn;
function no() {
  return to;
}
const ro = (e) => {
  const { data: t, path: n, errorMaps: r, issueData: a } = e, i = [...n, ...a.path || []], s = b(d({}, a), {
    path: i
  });
  if (a.message !== void 0)
    return b(d({}, a), {
      path: i,
      message: a.message
    });
  let o = "";
  const l = r.filter((c) => !!c).slice().reverse();
  for (const c of l)
    o = c(s, { data: t, defaultError: o }).message;
  return b(d({}, a), {
    path: i,
    message: o
  });
};
function h(e, t) {
  const n = no(), r = ro({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      // contextual error map is first priority
      e.schemaErrorMap,
      // then schema-bound map if available
      n,
      // then global override map
      n === bn ? void 0 : bn
      // then global default map
    ].filter((a) => !!a)
  });
  e.common.issues.push(r);
}
class U {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, n) {
    const r = [];
    for (const a of n) {
      if (a.status === "aborted")
        return y;
      a.status === "dirty" && t.dirty(), r.push(a.value);
    }
    return { status: t.value, value: r };
  }
  static mergeObjectAsync(t, n) {
    return N(this, null, function* () {
      const r = [];
      for (const a of n) {
        const i = yield a.key, s = yield a.value;
        r.push({
          key: i,
          value: s
        });
      }
      return U.mergeObjectSync(t, r);
    });
  }
  static mergeObjectSync(t, n) {
    const r = {};
    for (const a of n) {
      const { key: i, value: s } = a;
      if (i.status === "aborted" || s.status === "aborted")
        return y;
      i.status === "dirty" && t.dirty(), s.status === "dirty" && t.dirty(), i.value !== "__proto__" && (typeof s.value != "undefined" || a.alwaysSet) && (r[i.value] = s.value);
    }
    return { status: t.value, value: r };
  }
}
const y = Object.freeze({
  status: "aborted"
}), it = (e) => ({ status: "dirty", value: e }), Y = (e) => ({ status: "valid", value: e }), ar = (e) => e.status === "aborted", ir = (e) => e.status === "dirty", Be = (e) => e.status === "valid", Zt = (e) => typeof Promise != "undefined" && e instanceof Promise;
var p;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(p || (p = {}));
class le {
  constructor(t, n, r, a) {
    this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = a;
  }
  get path() {
    return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const sr = (e, t) => {
  if (Be(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new _e(e.common.issues);
      return this._error = n, this._error;
    }
  };
};
function w(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: n, required_error: r, description: a } = e;
  if (t && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: a } : { errorMap: (s, o) => {
    var c, f;
    const { message: l } = e;
    return s.code === "invalid_enum_value" ? { message: l != null ? l : o.defaultError } : typeof o.data == "undefined" ? { message: (c = l != null ? l : r) != null ? c : o.defaultError } : s.code !== "invalid_type" ? { message: o.defaultError } : { message: (f = l != null ? l : n) != null ? f : o.defaultError };
  }, description: a };
}
class k {
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return ve(t.data);
  }
  _getOrReturnCtx(t, n) {
    return n || {
      common: t.parent.common,
      data: t.data,
      parsedType: ve(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new U(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: ve(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (Zt(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n);
  }
  parse(t, n) {
    const r = this.safeParse(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, n) {
    var i;
    const r = {
      common: {
        issues: [],
        async: (i = n == null ? void 0 : n.async) != null ? i : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: ve(t)
    }, a = this._parseSync({ data: t, path: r.path, parent: r });
    return sr(r, a);
  }
  "~validate"(t) {
    var r, a;
    const n = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: ve(t)
    };
    if (!this["~standard"].async)
      try {
        const i = this._parseSync({ data: t, path: [], parent: n });
        return Be(i) ? {
          value: i.value
        } : {
          issues: n.common.issues
        };
      } catch (i) {
        (a = (r = i == null ? void 0 : i.message) == null ? void 0 : r.toLowerCase()) != null && a.includes("encountered") && (this["~standard"].async = !0), n.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data: t, path: [], parent: n }).then((i) => Be(i) ? {
      value: i.value
    } : {
      issues: n.common.issues
    });
  }
  parseAsync(t, n) {
    return N(this, null, function* () {
      const r = yield this.safeParseAsync(t, n);
      if (r.success)
        return r.data;
      throw r.error;
    });
  }
  safeParseAsync(t, n) {
    return N(this, null, function* () {
      const r = {
        common: {
          issues: [],
          contextualErrorMap: n == null ? void 0 : n.errorMap,
          async: !0
        },
        path: (n == null ? void 0 : n.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: ve(t)
      }, a = this._parse({ data: t, path: r.path, parent: r }), i = yield Zt(a) ? a : Promise.resolve(a);
      return sr(r, i);
    });
  }
  refine(t, n) {
    const r = (a) => typeof n == "string" || typeof n == "undefined" ? { message: n } : typeof n == "function" ? n(a) : n;
    return this._refinement((a, i) => {
      const s = t(a), o = () => i.addIssue(d({
        code: u.custom
      }, r(a)));
      return typeof Promise != "undefined" && s instanceof Promise ? s.then((l) => l ? !0 : (o(), !1)) : s ? !0 : (o(), !1);
    });
  }
  refinement(t, n) {
    return this._refinement((r, a) => t(r) ? !0 : (a.addIssue(typeof n == "function" ? n(r, a) : n), !1));
  }
  _refinement(t) {
    return new qe({
      schema: this,
      typeName: g.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (n) => this["~validate"](n)
    };
  }
  optional() {
    return Te.create(this, this._def);
  }
  nullable() {
    return Ke.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return oe.create(this);
  }
  promise() {
    return Lt.create(this, this._def);
  }
  or(t) {
    return jt.create([this, t], this._def);
  }
  and(t) {
    return $t.create(this, t, this._def);
  }
  transform(t) {
    return new qe(b(d({}, w(this._def)), {
      schema: this,
      typeName: g.ZodEffects,
      effect: { type: "transform", transform: t }
    }));
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Tn(b(d({}, w(this._def)), {
      innerType: this,
      defaultValue: n,
      typeName: g.ZodDefault
    }));
  }
  brand() {
    return new Eo(d({
      typeName: g.ZodBranded,
      type: this
    }, w(this._def)));
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t;
    return new An(b(d({}, w(this._def)), {
      innerType: this,
      catchValue: n,
      typeName: g.ZodCatch
    }));
  }
  describe(t) {
    const n = this.constructor;
    return new n(b(d({}, this._def), {
      description: t
    }));
  }
  pipe(t) {
    return $n.create(this, t);
  }
  readonly() {
    return En.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const ao = /^c[^\s-]{8,}$/i, io = /^[0-9a-z]+$/, so = /^[0-9A-HJKMNP-TV-Z]{26}$/i, oo = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, lo = /^[a-z0-9_-]{21}$/i, co = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, uo = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, fo = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, ho = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let en;
const _o = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, po = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, mo = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, go = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, yo = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, vo = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, ra = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", bo = new RegExp(`^${ra}$`);
function aa(e) {
  let t = "[0-5]\\d";
  e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`);
  const n = e.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${t})${n}`;
}
function wo(e) {
  return new RegExp(`^${aa(e)}$`);
}
function xo(e) {
  let t = `${ra}T${aa(e)}`;
  const n = [];
  return n.push(e.local ? "Z?" : "Z"), e.offset && n.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${n.join("|")})`, new RegExp(`^${t}$`);
}
function ko(e, t) {
  return !!((t === "v4" || !t) && _o.test(e) || (t === "v6" || !t) && mo.test(e));
}
function So(e, t) {
  if (!co.test(e))
    return !1;
  try {
    const [n] = e.split(".");
    if (!n)
      return !1;
    const r = n.replace(/-/g, "+").replace(/_/g, "/").padEnd(n.length + (4 - n.length % 4) % 4, "="), a = JSON.parse(atob(r));
    return !(typeof a != "object" || a === null || "typ" in a && (a == null ? void 0 : a.typ) !== "JWT" || !a.alg || t && a.alg !== t);
  } catch (n) {
    return !1;
  }
}
function To(e, t) {
  return !!((t === "v4" || !t) && po.test(e) || (t === "v6" || !t) && go.test(e));
}
class fe extends k {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== _.string) {
      const i = this._getOrReturnCtx(t);
      return h(i, {
        code: u.invalid_type,
        expected: _.string,
        received: i.parsedType
      }), y;
    }
    const r = new U();
    let a;
    for (const i of this._def.checks)
      if (i.kind === "min")
        t.data.length < i.value && (a = this._getOrReturnCtx(t, a), h(a, {
          code: u.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), r.dirty());
      else if (i.kind === "max")
        t.data.length > i.value && (a = this._getOrReturnCtx(t, a), h(a, {
          code: u.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), r.dirty());
      else if (i.kind === "length") {
        const s = t.data.length > i.value, o = t.data.length < i.value;
        (s || o) && (a = this._getOrReturnCtx(t, a), s ? h(a, {
          code: u.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }) : o && h(a, {
          code: u.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }), r.dirty());
      } else if (i.kind === "email")
        fo.test(t.data) || (a = this._getOrReturnCtx(t, a), h(a, {
          validation: "email",
          code: u.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "emoji")
        en || (en = new RegExp(ho, "u")), en.test(t.data) || (a = this._getOrReturnCtx(t, a), h(a, {
          validation: "emoji",
          code: u.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "uuid")
        oo.test(t.data) || (a = this._getOrReturnCtx(t, a), h(a, {
          validation: "uuid",
          code: u.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "nanoid")
        lo.test(t.data) || (a = this._getOrReturnCtx(t, a), h(a, {
          validation: "nanoid",
          code: u.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "cuid")
        ao.test(t.data) || (a = this._getOrReturnCtx(t, a), h(a, {
          validation: "cuid",
          code: u.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "cuid2")
        io.test(t.data) || (a = this._getOrReturnCtx(t, a), h(a, {
          validation: "cuid2",
          code: u.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "ulid")
        so.test(t.data) || (a = this._getOrReturnCtx(t, a), h(a, {
          validation: "ulid",
          code: u.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "url")
        try {
          new URL(t.data);
        } catch (s) {
          a = this._getOrReturnCtx(t, a), h(a, {
            validation: "url",
            code: u.invalid_string,
            message: i.message
          }), r.dirty();
        }
      else i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(t.data) || (a = this._getOrReturnCtx(t, a), h(a, {
        validation: "regex",
        code: u.invalid_string,
        message: i.message
      }), r.dirty())) : i.kind === "trim" ? t.data = t.data.trim() : i.kind === "includes" ? t.data.includes(i.value, i.position) || (a = this._getOrReturnCtx(t, a), h(a, {
        code: u.invalid_string,
        validation: { includes: i.value, position: i.position },
        message: i.message
      }), r.dirty()) : i.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : i.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : i.kind === "startsWith" ? t.data.startsWith(i.value) || (a = this._getOrReturnCtx(t, a), h(a, {
        code: u.invalid_string,
        validation: { startsWith: i.value },
        message: i.message
      }), r.dirty()) : i.kind === "endsWith" ? t.data.endsWith(i.value) || (a = this._getOrReturnCtx(t, a), h(a, {
        code: u.invalid_string,
        validation: { endsWith: i.value },
        message: i.message
      }), r.dirty()) : i.kind === "datetime" ? xo(i).test(t.data) || (a = this._getOrReturnCtx(t, a), h(a, {
        code: u.invalid_string,
        validation: "datetime",
        message: i.message
      }), r.dirty()) : i.kind === "date" ? bo.test(t.data) || (a = this._getOrReturnCtx(t, a), h(a, {
        code: u.invalid_string,
        validation: "date",
        message: i.message
      }), r.dirty()) : i.kind === "time" ? wo(i).test(t.data) || (a = this._getOrReturnCtx(t, a), h(a, {
        code: u.invalid_string,
        validation: "time",
        message: i.message
      }), r.dirty()) : i.kind === "duration" ? uo.test(t.data) || (a = this._getOrReturnCtx(t, a), h(a, {
        validation: "duration",
        code: u.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "ip" ? ko(t.data, i.version) || (a = this._getOrReturnCtx(t, a), h(a, {
        validation: "ip",
        code: u.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "jwt" ? So(t.data, i.alg) || (a = this._getOrReturnCtx(t, a), h(a, {
        validation: "jwt",
        code: u.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "cidr" ? To(t.data, i.version) || (a = this._getOrReturnCtx(t, a), h(a, {
        validation: "cidr",
        code: u.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "base64" ? yo.test(t.data) || (a = this._getOrReturnCtx(t, a), h(a, {
        validation: "base64",
        code: u.invalid_string,
        message: i.message
      }), r.dirty()) : i.kind === "base64url" ? vo.test(t.data) || (a = this._getOrReturnCtx(t, a), h(a, {
        validation: "base64url",
        code: u.invalid_string,
        message: i.message
      }), r.dirty()) : T.assertNever(i);
    return { status: r.value, value: t.data };
  }
  _regex(t, n, r) {
    return this.refinement((a) => t.test(a), d({
      validation: n,
      code: u.invalid_string
    }, p.errToObj(r)));
  }
  _addCheck(t) {
    return new fe(b(d({}, this._def), {
      checks: [...this._def.checks, t]
    }));
  }
  email(t) {
    return this._addCheck(d({ kind: "email" }, p.errToObj(t)));
  }
  url(t) {
    return this._addCheck(d({ kind: "url" }, p.errToObj(t)));
  }
  emoji(t) {
    return this._addCheck(d({ kind: "emoji" }, p.errToObj(t)));
  }
  uuid(t) {
    return this._addCheck(d({ kind: "uuid" }, p.errToObj(t)));
  }
  nanoid(t) {
    return this._addCheck(d({ kind: "nanoid" }, p.errToObj(t)));
  }
  cuid(t) {
    return this._addCheck(d({ kind: "cuid" }, p.errToObj(t)));
  }
  cuid2(t) {
    return this._addCheck(d({ kind: "cuid2" }, p.errToObj(t)));
  }
  ulid(t) {
    return this._addCheck(d({ kind: "ulid" }, p.errToObj(t)));
  }
  base64(t) {
    return this._addCheck(d({ kind: "base64" }, p.errToObj(t)));
  }
  base64url(t) {
    return this._addCheck(d({
      kind: "base64url"
    }, p.errToObj(t)));
  }
  jwt(t) {
    return this._addCheck(d({ kind: "jwt" }, p.errToObj(t)));
  }
  ip(t) {
    return this._addCheck(d({ kind: "ip" }, p.errToObj(t)));
  }
  cidr(t) {
    return this._addCheck(d({ kind: "cidr" }, p.errToObj(t)));
  }
  datetime(t) {
    var n, r;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: t
    }) : this._addCheck(d({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) == "undefined" ? null : t == null ? void 0 : t.precision,
      offset: (n = t == null ? void 0 : t.offset) != null ? n : !1,
      local: (r = t == null ? void 0 : t.local) != null ? r : !1
    }, p.errToObj(t == null ? void 0 : t.message)));
  }
  date(t) {
    return this._addCheck({ kind: "date", message: t });
  }
  time(t) {
    return typeof t == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: t
    }) : this._addCheck(d({
      kind: "time",
      precision: typeof (t == null ? void 0 : t.precision) == "undefined" ? null : t == null ? void 0 : t.precision
    }, p.errToObj(t == null ? void 0 : t.message)));
  }
  duration(t) {
    return this._addCheck(d({ kind: "duration" }, p.errToObj(t)));
  }
  regex(t, n) {
    return this._addCheck(d({
      kind: "regex",
      regex: t
    }, p.errToObj(n)));
  }
  includes(t, n) {
    return this._addCheck(d({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position
    }, p.errToObj(n == null ? void 0 : n.message)));
  }
  startsWith(t, n) {
    return this._addCheck(d({
      kind: "startsWith",
      value: t
    }, p.errToObj(n)));
  }
  endsWith(t, n) {
    return this._addCheck(d({
      kind: "endsWith",
      value: t
    }, p.errToObj(n)));
  }
  min(t, n) {
    return this._addCheck(d({
      kind: "min",
      value: t
    }, p.errToObj(n)));
  }
  max(t, n) {
    return this._addCheck(d({
      kind: "max",
      value: t
    }, p.errToObj(n)));
  }
  length(t, n) {
    return this._addCheck(d({
      kind: "length",
      value: t
    }, p.errToObj(n)));
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(t) {
    return this.min(1, p.errToObj(t));
  }
  trim() {
    return new fe(b(d({}, this._def), {
      checks: [...this._def.checks, { kind: "trim" }]
    }));
  }
  toLowerCase() {
    return new fe(b(d({}, this._def), {
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }));
  }
  toUpperCase() {
    return new fe(b(d({}, this._def), {
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    }));
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((t) => t.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((t) => t.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((t) => t.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((t) => t.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((t) => t.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((t) => t.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((t) => t.kind === "base64url");
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
fe.create = (e) => {
  var t;
  return new fe(d({
    checks: [],
    typeName: g.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) != null ? t : !1
  }, w(e)));
};
function Ao(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, a = n > r ? n : r, i = Number.parseInt(e.toFixed(a).replace(".", "")), s = Number.parseInt(t.toFixed(a).replace(".", ""));
  return i % s / Fn(10, a);
}
class He extends k {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== _.number) {
      const i = this._getOrReturnCtx(t);
      return h(i, {
        code: u.invalid_type,
        expected: _.number,
        received: i.parsedType
      }), y;
    }
    let r;
    const a = new U();
    for (const i of this._def.checks)
      i.kind === "int" ? T.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), h(r, {
        code: u.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), a.dirty()) : i.kind === "min" ? (i.inclusive ? t.data < i.value : t.data <= i.value) && (r = this._getOrReturnCtx(t, r), h(r, {
        code: u.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), a.dirty()) : i.kind === "max" ? (i.inclusive ? t.data > i.value : t.data >= i.value) && (r = this._getOrReturnCtx(t, r), h(r, {
        code: u.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), a.dirty()) : i.kind === "multipleOf" ? Ao(t.data, i.value) !== 0 && (r = this._getOrReturnCtx(t, r), h(r, {
        code: u.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), a.dirty()) : i.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), h(r, {
        code: u.not_finite,
        message: i.message
      }), a.dirty()) : T.assertNever(i);
    return { status: a.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, p.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, p.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, p.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, p.toString(n));
  }
  setLimit(t, n, r, a) {
    return new He(b(d({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: p.toString(a)
        }
      ]
    }));
  }
  _addCheck(t) {
    return new He(b(d({}, this._def), {
      checks: [...this._def.checks, t]
    }));
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: p.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: p.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: p.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: p.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: p.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: p.toString(n)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: p.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: p.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: p.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && T.isInteger(t.value));
  }
  get isFinite() {
    let t = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(t);
  }
}
He.create = (e) => new He(d({
  checks: [],
  typeName: g.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1
}, w(e)));
class _t extends k {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce)
      try {
        t.data = BigInt(t.data);
      } catch (i) {
        return this._getInvalidInput(t);
      }
    if (this._getType(t) !== _.bigint)
      return this._getInvalidInput(t);
    let r;
    const a = new U();
    for (const i of this._def.checks)
      i.kind === "min" ? (i.inclusive ? t.data < i.value : t.data <= i.value) && (r = this._getOrReturnCtx(t, r), h(r, {
        code: u.too_small,
        type: "bigint",
        minimum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), a.dirty()) : i.kind === "max" ? (i.inclusive ? t.data > i.value : t.data >= i.value) && (r = this._getOrReturnCtx(t, r), h(r, {
        code: u.too_big,
        type: "bigint",
        maximum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), a.dirty()) : i.kind === "multipleOf" ? t.data % i.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), h(r, {
        code: u.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), a.dirty()) : T.assertNever(i);
    return { status: a.value, value: t.data };
  }
  _getInvalidInput(t) {
    const n = this._getOrReturnCtx(t);
    return h(n, {
      code: u.invalid_type,
      expected: _.bigint,
      received: n.parsedType
    }), y;
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, p.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, p.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, p.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, p.toString(n));
  }
  setLimit(t, n, r, a) {
    return new _t(b(d({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: p.toString(a)
        }
      ]
    }));
  }
  _addCheck(t) {
    return new _t(b(d({}, this._def), {
      checks: [...this._def.checks, t]
    }));
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: p.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: p.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: p.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: p.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: p.toString(n)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
_t.create = (e) => {
  var t;
  return new _t(d({
    checks: [],
    typeName: g.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) != null ? t : !1
  }, w(e)));
};
class wn extends k {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== _.boolean) {
      const r = this._getOrReturnCtx(t);
      return h(r, {
        code: u.invalid_type,
        expected: _.boolean,
        received: r.parsedType
      }), y;
    }
    return Y(t.data);
  }
}
wn.create = (e) => new wn(d({
  typeName: g.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1
}, w(e)));
class zt extends k {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== _.date) {
      const i = this._getOrReturnCtx(t);
      return h(i, {
        code: u.invalid_type,
        expected: _.date,
        received: i.parsedType
      }), y;
    }
    if (Number.isNaN(t.data.getTime())) {
      const i = this._getOrReturnCtx(t);
      return h(i, {
        code: u.invalid_date
      }), y;
    }
    const r = new U();
    let a;
    for (const i of this._def.checks)
      i.kind === "min" ? t.data.getTime() < i.value && (a = this._getOrReturnCtx(t, a), h(a, {
        code: u.too_small,
        message: i.message,
        inclusive: !0,
        exact: !1,
        minimum: i.value,
        type: "date"
      }), r.dirty()) : i.kind === "max" ? t.data.getTime() > i.value && (a = this._getOrReturnCtx(t, a), h(a, {
        code: u.too_big,
        message: i.message,
        inclusive: !0,
        exact: !1,
        maximum: i.value,
        type: "date"
      }), r.dirty()) : T.assertNever(i);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new zt(b(d({}, this._def), {
      checks: [...this._def.checks, t]
    }));
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: p.toString(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: p.toString(n)
    });
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
}
zt.create = (e) => new zt(d({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: g.ZodDate
}, w(e)));
class or extends k {
  _parse(t) {
    if (this._getType(t) !== _.symbol) {
      const r = this._getOrReturnCtx(t);
      return h(r, {
        code: u.invalid_type,
        expected: _.symbol,
        received: r.parsedType
      }), y;
    }
    return Y(t.data);
  }
}
or.create = (e) => new or(d({
  typeName: g.ZodSymbol
}, w(e)));
class lr extends k {
  _parse(t) {
    if (this._getType(t) !== _.undefined) {
      const r = this._getOrReturnCtx(t);
      return h(r, {
        code: u.invalid_type,
        expected: _.undefined,
        received: r.parsedType
      }), y;
    }
    return Y(t.data);
  }
}
lr.create = (e) => new lr(d({
  typeName: g.ZodUndefined
}, w(e)));
class cr extends k {
  _parse(t) {
    if (this._getType(t) !== _.null) {
      const r = this._getOrReturnCtx(t);
      return h(r, {
        code: u.invalid_type,
        expected: _.null,
        received: r.parsedType
      }), y;
    }
    return Y(t.data);
  }
}
cr.create = (e) => new cr(d({
  typeName: g.ZodNull
}, w(e)));
class dr extends k {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return Y(t.data);
  }
}
dr.create = (e) => new dr(d({
  typeName: g.ZodAny
}, w(e)));
class xn extends k {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return Y(t.data);
  }
}
xn.create = (e) => new xn(d({
  typeName: g.ZodUnknown
}, w(e)));
class Ae extends k {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return h(n, {
      code: u.invalid_type,
      expected: _.never,
      received: n.parsedType
    }), y;
  }
}
Ae.create = (e) => new Ae(d({
  typeName: g.ZodNever
}, w(e)));
class ur extends k {
  _parse(t) {
    if (this._getType(t) !== _.undefined) {
      const r = this._getOrReturnCtx(t);
      return h(r, {
        code: u.invalid_type,
        expected: _.void,
        received: r.parsedType
      }), y;
    }
    return Y(t.data);
  }
}
ur.create = (e) => new ur(d({
  typeName: g.ZodVoid
}, w(e)));
class oe extends k {
  _parse(t) {
    const { ctx: n, status: r } = this._processInputParams(t), a = this._def;
    if (n.parsedType !== _.array)
      return h(n, {
        code: u.invalid_type,
        expected: _.array,
        received: n.parsedType
      }), y;
    if (a.exactLength !== null) {
      const s = n.data.length > a.exactLength.value, o = n.data.length < a.exactLength.value;
      (s || o) && (h(n, {
        code: s ? u.too_big : u.too_small,
        minimum: o ? a.exactLength.value : void 0,
        maximum: s ? a.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: a.exactLength.message
      }), r.dirty());
    }
    if (a.minLength !== null && n.data.length < a.minLength.value && (h(n, {
      code: u.too_small,
      minimum: a.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: a.minLength.message
    }), r.dirty()), a.maxLength !== null && n.data.length > a.maxLength.value && (h(n, {
      code: u.too_big,
      maximum: a.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: a.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all([...n.data].map((s, o) => a.type._parseAsync(new le(n, s, n.path, o)))).then((s) => U.mergeArray(r, s));
    const i = [...n.data].map((s, o) => a.type._parseSync(new le(n, s, n.path, o)));
    return U.mergeArray(r, i);
  }
  get element() {
    return this._def.type;
  }
  min(t, n) {
    return new oe(b(d({}, this._def), {
      minLength: { value: t, message: p.toString(n) }
    }));
  }
  max(t, n) {
    return new oe(b(d({}, this._def), {
      maxLength: { value: t, message: p.toString(n) }
    }));
  }
  length(t, n) {
    return new oe(b(d({}, this._def), {
      exactLength: { value: t, message: p.toString(n) }
    }));
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
oe.create = (e, t) => new oe(d({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: g.ZodArray
}, w(t)));
function Me(e) {
  if (e instanceof Z) {
    const t = {};
    for (const n in e.shape) {
      const r = e.shape[n];
      t[n] = Te.create(Me(r));
    }
    return new Z(b(d({}, e._def), {
      shape: () => t
    }));
  } else return e instanceof oe ? new oe(b(d({}, e._def), {
    type: Me(e.element)
  })) : e instanceof Te ? Te.create(Me(e.unwrap())) : e instanceof Ke ? Ke.create(Me(e.unwrap())) : e instanceof je ? je.create(e.items.map((t) => Me(t))) : e;
}
class Z extends k {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), n = T.objectKeys(t);
    return this._cached = { shape: t, keys: n }, this._cached;
  }
  _parse(t) {
    if (this._getType(t) !== _.object) {
      const c = this._getOrReturnCtx(t);
      return h(c, {
        code: u.invalid_type,
        expected: _.object,
        received: c.parsedType
      }), y;
    }
    const { status: r, ctx: a } = this._processInputParams(t), { shape: i, keys: s } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof Ae && this._def.unknownKeys === "strip"))
      for (const c in a.data)
        s.includes(c) || o.push(c);
    const l = [];
    for (const c of s) {
      const f = i[c], m = a.data[c];
      l.push({
        key: { status: "valid", value: c },
        value: f._parse(new le(a, m, a.path, c)),
        alwaysSet: c in a.data
      });
    }
    if (this._def.catchall instanceof Ae) {
      const c = this._def.unknownKeys;
      if (c === "passthrough")
        for (const f of o)
          l.push({
            key: { status: "valid", value: f },
            value: { status: "valid", value: a.data[f] }
          });
      else if (c === "strict")
        o.length > 0 && (h(a, {
          code: u.unrecognized_keys,
          keys: o
        }), r.dirty());
      else if (c !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const c = this._def.catchall;
      for (const f of o) {
        const m = a.data[f];
        l.push({
          key: { status: "valid", value: f },
          value: c._parse(
            new le(a, m, a.path, f)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: f in a.data
        });
      }
    }
    return a.common.async ? Promise.resolve().then(() => N(this, null, function* () {
      const c = [];
      for (const f of l) {
        const m = yield f.key, v = yield f.value;
        c.push({
          key: m,
          value: v,
          alwaysSet: f.alwaysSet
        });
      }
      return c;
    })).then((c) => U.mergeObjectSync(r, c)) : U.mergeObjectSync(r, l);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return p.errToObj, new Z(d(b(d({}, this._def), {
      unknownKeys: "strict"
    }), t !== void 0 ? {
      errorMap: (n, r) => {
        var i, s, o, l;
        const a = (o = (s = (i = this._def).errorMap) == null ? void 0 : s.call(i, n, r).message) != null ? o : r.defaultError;
        return n.code === "unrecognized_keys" ? {
          message: (l = p.errToObj(t).message) != null ? l : a
        } : {
          message: a
        };
      }
    } : {}));
  }
  strip() {
    return new Z(b(d({}, this._def), {
      unknownKeys: "strip"
    }));
  }
  passthrough() {
    return new Z(b(d({}, this._def), {
      unknownKeys: "passthrough"
    }));
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new Z(b(d({}, this._def), {
      shape: () => d(d({}, this._def.shape()), t)
    }));
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new Z({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => d(d({}, this._def.shape()), t._def.shape()),
      typeName: g.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, n) {
    return this.augment({ [t]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new Z(b(d({}, this._def), {
      catchall: t
    }));
  }
  pick(t) {
    const n = {};
    for (const r of T.objectKeys(t))
      t[r] && this.shape[r] && (n[r] = this.shape[r]);
    return new Z(b(d({}, this._def), {
      shape: () => n
    }));
  }
  omit(t) {
    const n = {};
    for (const r of T.objectKeys(this.shape))
      t[r] || (n[r] = this.shape[r]);
    return new Z(b(d({}, this._def), {
      shape: () => n
    }));
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Me(this);
  }
  partial(t) {
    const n = {};
    for (const r of T.objectKeys(this.shape)) {
      const a = this.shape[r];
      t && !t[r] ? n[r] = a : n[r] = a.optional();
    }
    return new Z(b(d({}, this._def), {
      shape: () => n
    }));
  }
  required(t) {
    const n = {};
    for (const r of T.objectKeys(this.shape))
      if (t && !t[r])
        n[r] = this.shape[r];
      else {
        let i = this.shape[r];
        for (; i instanceof Te; )
          i = i._def.innerType;
        n[r] = i;
      }
    return new Z(b(d({}, this._def), {
      shape: () => n
    }));
  }
  keyof() {
    return ia(T.objectKeys(this.shape));
  }
}
Z.create = (e, t) => new Z(d({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Ae.create(),
  typeName: g.ZodObject
}, w(t)));
Z.strictCreate = (e, t) => new Z(d({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Ae.create(),
  typeName: g.ZodObject
}, w(t)));
Z.lazycreate = (e, t) => new Z(d({
  shape: e,
  unknownKeys: "strip",
  catchall: Ae.create(),
  typeName: g.ZodObject
}, w(t)));
class jt extends k {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = this._def.options;
    function a(i) {
      for (const o of i)
        if (o.result.status === "valid")
          return o.result;
      for (const o of i)
        if (o.result.status === "dirty")
          return n.common.issues.push(...o.ctx.common.issues), o.result;
      const s = i.map((o) => new _e(o.ctx.common.issues));
      return h(n, {
        code: u.invalid_union,
        unionErrors: s
      }), y;
    }
    if (n.common.async)
      return Promise.all(r.map((i) => N(this, null, function* () {
        const s = b(d({}, n), {
          common: b(d({}, n.common), {
            issues: []
          }),
          parent: null
        });
        return {
          result: yield i._parseAsync({
            data: n.data,
            path: n.path,
            parent: s
          }),
          ctx: s
        };
      }))).then(a);
    {
      let i;
      const s = [];
      for (const l of r) {
        const c = b(d({}, n), {
          common: b(d({}, n.common), {
            issues: []
          }),
          parent: null
        }), f = l._parseSync({
          data: n.data,
          path: n.path,
          parent: c
        });
        if (f.status === "valid")
          return f;
        f.status === "dirty" && !i && (i = { result: f, ctx: c }), c.common.issues.length && s.push(c.common.issues);
      }
      if (i)
        return n.common.issues.push(...i.ctx.common.issues), i.result;
      const o = s.map((l) => new _e(l));
      return h(n, {
        code: u.invalid_union,
        unionErrors: o
      }), y;
    }
  }
  get options() {
    return this._def.options;
  }
}
jt.create = (e, t) => new jt(d({
  options: e,
  typeName: g.ZodUnion
}, w(t)));
function kn(e, t) {
  const n = ve(e), r = ve(t);
  if (e === t)
    return { valid: !0, data: e };
  if (n === _.object && r === _.object) {
    const a = T.objectKeys(t), i = T.objectKeys(e).filter((o) => a.indexOf(o) !== -1), s = d(d({}, e), t);
    for (const o of i) {
      const l = kn(e[o], t[o]);
      if (!l.valid)
        return { valid: !1 };
      s[o] = l.data;
    }
    return { valid: !0, data: s };
  } else if (n === _.array && r === _.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const a = [];
    for (let i = 0; i < e.length; i++) {
      const s = e[i], o = t[i], l = kn(s, o);
      if (!l.valid)
        return { valid: !1 };
      a.push(l.data);
    }
    return { valid: !0, data: a };
  } else return n === _.date && r === _.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class $t extends k {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), a = (i, s) => {
      if (ar(i) || ar(s))
        return y;
      const o = kn(i.value, s.value);
      return o.valid ? ((ir(i) || ir(s)) && n.dirty(), { status: n.value, value: o.data }) : (h(r, {
        code: u.invalid_intersection_types
      }), y);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([i, s]) => a(i, s)) : a(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
$t.create = (e, t, n) => new $t(d({
  left: e,
  right: t,
  typeName: g.ZodIntersection
}, w(n)));
class je extends k {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== _.array)
      return h(r, {
        code: u.invalid_type,
        expected: _.array,
        received: r.parsedType
      }), y;
    if (r.data.length < this._def.items.length)
      return h(r, {
        code: u.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), y;
    !this._def.rest && r.data.length > this._def.items.length && (h(r, {
      code: u.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const i = [...r.data].map((s, o) => {
      const l = this._def.items[o] || this._def.rest;
      return l ? l._parse(new le(r, s, r.path, o)) : null;
    }).filter((s) => !!s);
    return r.common.async ? Promise.all(i).then((s) => U.mergeArray(n, s)) : U.mergeArray(n, i);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new je(b(d({}, this._def), {
      rest: t
    }));
  }
}
je.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new je(d({
    items: e,
    typeName: g.ZodTuple,
    rest: null
  }, w(t)));
};
class Dt extends k {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== _.object)
      return h(r, {
        code: u.invalid_type,
        expected: _.object,
        received: r.parsedType
      }), y;
    const a = [], i = this._def.keyType, s = this._def.valueType;
    for (const o in r.data)
      a.push({
        key: i._parse(new le(r, o, r.path, o)),
        value: s._parse(new le(r, r.data[o], r.path, o)),
        alwaysSet: o in r.data
      });
    return r.common.async ? U.mergeObjectAsync(n, a) : U.mergeObjectSync(n, a);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, n, r) {
    return n instanceof k ? new Dt(d({
      keyType: t,
      valueType: n,
      typeName: g.ZodRecord
    }, w(r))) : new Dt(d({
      keyType: fe.create(),
      valueType: t,
      typeName: g.ZodRecord
    }, w(n)));
  }
}
class fr extends k {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== _.map)
      return h(r, {
        code: u.invalid_type,
        expected: _.map,
        received: r.parsedType
      }), y;
    const a = this._def.keyType, i = this._def.valueType, s = [...r.data.entries()].map(([o, l], c) => ({
      key: a._parse(new le(r, o, r.path, [c, "key"])),
      value: i._parse(new le(r, l, r.path, [c, "value"]))
    }));
    if (r.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(() => N(this, null, function* () {
        for (const l of s) {
          const c = yield l.key, f = yield l.value;
          if (c.status === "aborted" || f.status === "aborted")
            return y;
          (c.status === "dirty" || f.status === "dirty") && n.dirty(), o.set(c.value, f.value);
        }
        return { status: n.value, value: o };
      }));
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const l of s) {
        const c = l.key, f = l.value;
        if (c.status === "aborted" || f.status === "aborted")
          return y;
        (c.status === "dirty" || f.status === "dirty") && n.dirty(), o.set(c.value, f.value);
      }
      return { status: n.value, value: o };
    }
  }
}
fr.create = (e, t, n) => new fr(d({
  valueType: t,
  keyType: e,
  typeName: g.ZodMap
}, w(n)));
class pt extends k {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== _.set)
      return h(r, {
        code: u.invalid_type,
        expected: _.set,
        received: r.parsedType
      }), y;
    const a = this._def;
    a.minSize !== null && r.data.size < a.minSize.value && (h(r, {
      code: u.too_small,
      minimum: a.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: a.minSize.message
    }), n.dirty()), a.maxSize !== null && r.data.size > a.maxSize.value && (h(r, {
      code: u.too_big,
      maximum: a.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: a.maxSize.message
    }), n.dirty());
    const i = this._def.valueType;
    function s(l) {
      const c = /* @__PURE__ */ new Set();
      for (const f of l) {
        if (f.status === "aborted")
          return y;
        f.status === "dirty" && n.dirty(), c.add(f.value);
      }
      return { status: n.value, value: c };
    }
    const o = [...r.data.values()].map((l, c) => i._parse(new le(r, l, r.path, c)));
    return r.common.async ? Promise.all(o).then((l) => s(l)) : s(o);
  }
  min(t, n) {
    return new pt(b(d({}, this._def), {
      minSize: { value: t, message: p.toString(n) }
    }));
  }
  max(t, n) {
    return new pt(b(d({}, this._def), {
      maxSize: { value: t, message: p.toString(n) }
    }));
  }
  size(t, n) {
    return this.min(t, n).max(t, n);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
pt.create = (e, t) => new pt(d({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: g.ZodSet
}, w(t)));
class hr extends k {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
hr.create = (e, t) => new hr(d({
  getter: e,
  typeName: g.ZodLazy
}, w(t)));
class Sn extends k {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return h(n, {
        received: n.data,
        code: u.invalid_literal,
        expected: this._def.value
      }), y;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
Sn.create = (e, t) => new Sn(d({
  value: e,
  typeName: g.ZodLiteral
}, w(t)));
function ia(e, t) {
  return new We(d({
    values: e,
    typeName: g.ZodEnum
  }, w(t)));
}
class We extends k {
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return h(n, {
        expected: T.joinValues(r),
        received: n.parsedType,
        code: u.invalid_type
      }), y;
    }
    if (this._cache || (this._cache = new Set(this._def.values)), !this._cache.has(t.data)) {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return h(n, {
        received: n.data,
        code: u.invalid_enum_value,
        options: r
      }), y;
    }
    return Y(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Values() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  extract(t, n = this._def) {
    return We.create(t, d(d({}, this._def), n));
  }
  exclude(t, n = this._def) {
    return We.create(this.options.filter((r) => !t.includes(r)), d(d({}, this._def), n));
  }
}
We.create = ia;
class _r extends k {
  _parse(t) {
    const n = T.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== _.string && r.parsedType !== _.number) {
      const a = T.objectValues(n);
      return h(r, {
        expected: T.joinValues(a),
        received: r.parsedType,
        code: u.invalid_type
      }), y;
    }
    if (this._cache || (this._cache = new Set(T.getValidEnumValues(this._def.values))), !this._cache.has(t.data)) {
      const a = T.objectValues(n);
      return h(r, {
        received: r.data,
        code: u.invalid_enum_value,
        options: a
      }), y;
    }
    return Y(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
_r.create = (e, t) => new _r(d({
  values: e,
  typeName: g.ZodNativeEnum
}, w(t)));
class Lt extends k {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== _.promise && n.common.async === !1)
      return h(n, {
        code: u.invalid_type,
        expected: _.promise,
        received: n.parsedType
      }), y;
    const r = n.parsedType === _.promise ? n.data : Promise.resolve(n.data);
    return Y(r.then((a) => this._def.type.parseAsync(a, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
Lt.create = (e, t) => new Lt(d({
  type: e,
  typeName: g.ZodPromise
}, w(t)));
class qe extends k {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === g.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), a = this._def.effect || null, i = {
      addIssue: (s) => {
        h(r, s), s.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), a.type === "preprocess") {
      const s = a.transform(r.data, i);
      if (r.common.async)
        return Promise.resolve(s).then((o) => N(this, null, function* () {
          if (n.value === "aborted")
            return y;
          const l = yield this._def.schema._parseAsync({
            data: o,
            path: r.path,
            parent: r
          });
          return l.status === "aborted" ? y : l.status === "dirty" || n.value === "dirty" ? it(l.value) : l;
        }));
      {
        if (n.value === "aborted")
          return y;
        const o = this._def.schema._parseSync({
          data: s,
          path: r.path,
          parent: r
        });
        return o.status === "aborted" ? y : o.status === "dirty" || n.value === "dirty" ? it(o.value) : o;
      }
    }
    if (a.type === "refinement") {
      const s = (o) => {
        const l = a.refinement(o, i);
        if (r.common.async)
          return Promise.resolve(l);
        if (l instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return o.status === "aborted" ? y : (o.status === "dirty" && n.dirty(), s(o.value), { status: n.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => o.status === "aborted" ? y : (o.status === "dirty" && n.dirty(), s(o.value).then(() => ({ status: n.value, value: o.value }))));
    }
    if (a.type === "transform")
      if (r.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!Be(s))
          return y;
        const o = a.transform(s.value, i);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((s) => Be(s) ? Promise.resolve(a.transform(s.value, i)).then((o) => ({
          status: n.value,
          value: o
        })) : y);
    T.assertNever(a);
  }
}
qe.create = (e, t, n) => new qe(d({
  schema: e,
  typeName: g.ZodEffects,
  effect: t
}, w(n)));
qe.createWithPreprocess = (e, t, n) => new qe(d({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: g.ZodEffects
}, w(n)));
class Te extends k {
  _parse(t) {
    return this._getType(t) === _.undefined ? Y(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Te.create = (e, t) => new Te(d({
  innerType: e,
  typeName: g.ZodOptional
}, w(t)));
class Ke extends k {
  _parse(t) {
    return this._getType(t) === _.null ? Y(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Ke.create = (e, t) => new Ke(d({
  innerType: e,
  typeName: g.ZodNullable
}, w(t)));
class Tn extends k {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    let r = n.data;
    return n.parsedType === _.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Tn.create = (e, t) => new Tn(d({
  innerType: e,
  typeName: g.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default
}, w(t)));
class An extends k {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = b(d({}, n), {
      common: b(d({}, n.common), {
        issues: []
      })
    }), a = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: d({}, r)
    });
    return Zt(a) ? a.then((i) => ({
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new _e(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new _e(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
An.create = (e, t) => new An(d({
  innerType: e,
  typeName: g.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch
}, w(t)));
class pr extends k {
  _parse(t) {
    if (this._getType(t) !== _.nan) {
      const r = this._getOrReturnCtx(t);
      return h(r, {
        code: u.invalid_type,
        expected: _.nan,
        received: r.parsedType
      }), y;
    }
    return { status: "valid", value: t.data };
  }
}
pr.create = (e) => new pr(d({
  typeName: g.ZodNaN
}, w(e)));
class Eo extends k {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class $n extends k {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return N(this, null, function* () {
        const i = yield this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return i.status === "aborted" ? y : i.status === "dirty" ? (n.dirty(), it(i.value)) : this._def.out._parseAsync({
          data: i.value,
          path: r.path,
          parent: r
        });
      });
    {
      const a = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return a.status === "aborted" ? y : a.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: a.value
      }) : this._def.out._parseSync({
        data: a.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, n) {
    return new $n({
      in: t,
      out: n,
      typeName: g.ZodPipeline
    });
  }
}
class En extends k {
  _parse(t) {
    const n = this._def.innerType._parse(t), r = (a) => (Be(a) && (a.value = Object.freeze(a.value)), a);
    return Zt(n) ? n.then((a) => r(a)) : r(n);
  }
  unwrap() {
    return this._def.innerType;
  }
}
En.create = (e, t) => new En(d({
  innerType: e,
  typeName: g.ZodReadonly
}, w(t)));
var g;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(g || (g = {}));
const kt = fe.create, Oo = He.create, Q = wn.create, Co = xn.create;
Ae.create;
const mr = oe.create, St = Z.create, No = jt.create;
$t.create;
je.create;
const Io = Dt.create, gr = Sn.create, Tt = We.create;
Lt.create;
Te.create;
Ke.create;
const Ro = St({
  language: Tt(["typescript", "javascript"]).optional(),
  disableMarkedForExport: Q().optional(),
  allowAutoSelectFirstNode: Q().optional().default(!0),
  enableDisplayDataId: Q().optional(),
  enableDisplayDataName: Q().optional()
}).and(
  No([
    St({
      framework: gr("react"),
      model: kt().optional(),
      styling: Tt([
        "plain_css",
        "css_modules",
        "styled_components",
        "tailwind",
        "sass",
        "scss",
        "inline_styles"
      ]),
      uiLibrary: Tt(["mui", "antd", "radix", "shadcn", "clean_react"]).optional(),
      responsivePages: mr(
        St({
          name: kt(),
          framesId: mr(kt())
        })
      ).optional(),
      enableUILibraryTheming: Q().optional(),
      enableCompactStructure: Q().optional(),
      enableDisplayScreenModelId: Q().optional(),
      enableGeneratePackageLock: Q().optional(),
      enableAnimationsPreset: Q().optional(),
      enableAutoSplit: Q().optional(),
      autoSplitThreshold: Oo().optional(),
      url: kt().url().optional(),
      codegenSettings: Io(Co()).optional()
    }),
    St({
      framework: gr("html"),
      styling: Tt(["plain_css", "inline_styles", "tailwind"]),
      enableTranslation: Q().optional()
    })
  ])
), Zo = (e) => {
  const t = Ro.safeParse(e);
  if (t.success === !1) {
    const n = new Error("Invalid codegen settings");
    throw n.cause = t.error, n;
  }
  return t.data;
}, yr = /* @__PURE__ */ new Set([
  "FRAME",
  "INSTANCE",
  "COMPONENT",
  "COMPONENT_SET",
  "GROUP"
]), zo = (e, t, n = { allowAutoSelectFirstNode: !0 }) => {
  const r = na(e.document, t);
  if (!r)
    return {
      isValid: !1,
      reason: "There is no node with the given id"
    };
  if (r.type === "CANVAS") {
    const a = r.children.filter(
      (i) => yr.has(i.type)
    );
    return a.length === 0 ? {
      isValid: !1,
      reason: "Selected node is a page with no valid children"
    } : a.length === 1 ? {
      isValid: !0,
      node: a[0],
      note: "Selected node is a page with a single valid children - returning it instead"
    } : n.allowAutoSelectFirstNode ? {
      isValid: !0,
      node: a[0],
      note: "Selected node is a page with multiple valid children - returning the first one instead"
    } : {
      isValid: !1,
      reason: "Selected node is a page with multiple children"
    };
  }
  return yr.has(r.type) ? { isValid: !0, node: r } : {
    isValid: !1,
    reason: "Selected node type is not supported"
  };
};
var O, mt, he, sa, st;
class qo {
  constructor({
    auth: t,
    apiBaseAddress: n = "https://public-api.animaapp.com"
  } = {}) {
    wt(this, he);
    wt(this, O);
    wt(this, mt);
    Bt(this, mt, n), t && (this.auth = t);
  }
  hasAuth() {
    return !!C(this, O);
  }
  set auth(t) {
    Bt(this, O, t);
  }
  get headers() {
    const t = {
      "Content-Type": "application/json"
    };
    return C(this, O) && (t.Authorization = `Bearer ${C(this, O).token}`, "teamId" in C(this, O) && (t["X-Team-Id"] = C(this, O).teamId)), t;
  }
  generateCode(a) {
    return N(this, arguments, function* (t, n = {}, r) {
      var c;
      let i;
      try {
        i = yield eo({
          fileKey: t.fileKey,
          authToken: t.figmaToken,
          params: {
            geometry: "paths"
          },
          signal: r
        });
      } catch (f) {
        if (f instanceof Error && f.name === "AbortError")
          throw f;
      }
      const s = Zo(t.settings);
      i && (yield De(this, he, sa).call(this, i, t.nodesId, {
        allowAutoSelectFirstNode: (c = s.allowAutoSelectFirstNode) != null ? c : !0
      }));
      let o = t.tracking;
      C(this, O) && "userId" in C(this, O) && C(this, O).userId && (o != null && o.externalId || (o = { externalId: C(this, O).userId }));
      const l = {
        tracking: o,
        fileKey: t.fileKey,
        figmaToken: t.figmaToken,
        nodesId: t.nodesId,
        design: i,
        assetsStorage: t.assetsStorage,
        language: s.language,
        model: s.model,
        framework: s.framework,
        styling: s.styling,
        uiLibrary: s.uiLibrary,
        enableTranslation: s.enableTranslation,
        enableUILibraryTheming: s.enableUILibraryTheming,
        enableCompactStructure: s.enableCompactStructure,
        enableAutoSplit: s.enableAutoSplit,
        autoSplitThreshold: s.autoSplitThreshold,
        disableMarkedForExport: s.disableMarkedForExport,
        allowAutoSelectFirstNode: s.allowAutoSelectFirstNode,
        enableDisplayScreenModelId: s.enableDisplayScreenModelId,
        enableGeneratePackageLock: s.enableGeneratePackageLock,
        enableAnimationsPreset: s.enableAnimationsPreset,
        enableDisplayDataId: s.enableDisplayDataId,
        enableDisplayDataName: s.enableDisplayDataName,
        codegenSettings: s.codegenSettings,
        webhookUrl: t.webhookUrl,
        prompt: t.prompt,
        images: t.images
      };
      return De(this, he, st).call(this, "/v1/codegen", l, n, "codegen", r);
    });
  }
  generateCodeFromWebsite(a) {
    return N(this, arguments, function* (t, n = {}, r) {
      let i = t.tracking;
      C(this, O) && "userId" in C(this, O) && C(this, O).userId && (i != null && i.externalId || (i = { externalId: C(this, O).userId }));
      let s;
      if (t.mhtml)
        s = {
          type: "mhtml",
          mhtml: t.mhtml,
          url: t.url
        };
      else if (t.url)
        s = {
          type: "url",
          url: t.url
        };
      else
        throw new Error("Either 'url' or 'mhtml' must be provided");
      let o;
      t.experimental_useNewReactEngine && (o = "react-v2");
      const l = {
        tracking: i,
        assetsStorage: t.assetsStorage,
        prompt: t.prompt,
        images: t.images,
        params: {
          input: s,
          conventions: {
            framework: t.settings.framework,
            language: t.settings.language,
            styling: t.settings.styling
          },
          assetsStorage: {
            type: "bundled"
          },
          engine: o
        }
      };
      return De(this, he, st).call(this, "/v1/l2c", l, n, "l2c", r);
    });
  }
  /**
   * Generates code from a text prompt using AI.
   *
   * This method sends a prompt to the Anima API and generates code based on the description provided.
   * It supports real-time streaming of the generation process through Server-Sent Events (SSE).
   *
   * @param params - The parameters for code generation
   * @param params.prompt - The text prompt describing what code to generate
   * @param params.settings - Code generation settings (framework, language, styling, etc.)
   * @param params.assetsStorage - Optional asset storage configuration
   * @param params.tracking - Optional tracking information
   * @param params.webhookUrl - Optional webhook URL for completion notification
   * @param handler - Event handler for processing SSE messages during generation
   * @param signal - Optional AbortSignal to cancel the request
   * @returns Promise resolving to AnimaSDKResult with generated files and metadata
   *
   * @example
   * ```typescript
   * const result = await anima.generateCodeFromPrompt({
   *   prompt: "Create a login form with email and password fields",
   *   settings: {
   *     framework: "react",
   *     language: "typescript",
   *     styling: "tailwind"
   *   }
   * }, {
   *   onStart: ({ sessionId }) => console.log("Started:", sessionId),
   *   onGeneratingCode: ({ progress }) => console.log("Progress:", progress),
   *   onCodegenCompleted: () => console.log("Generation completed!")
   * });
   * ```
   */
  generateCodeFromPrompt(a) {
    return N(this, arguments, function* (t, n = {}, r) {
      var o;
      let i = t.tracking;
      C(this, O) && "userId" in C(this, O) && C(this, O).userId && (i != null && i.externalId || (i = { externalId: C(this, O).userId }));
      const s = {
        tracking: i,
        assetsStorage: t.assetsStorage,
        params: d({
          prompt: t.prompt,
          images: t.images,
          conventions: {
            language: t.settings.language,
            framework: t.settings.framework,
            styling: t.settings.styling,
            uiLibrary: t.settings.uiLibrary
          }
        }, (o = t.settings.codegenSettings) != null ? o : {}),
        webhookUrl: t.webhookUrl
      };
      return De(this, he, st).call(this, "/v1/p2c", s, n, "p2c", r);
    });
  }
  /**
   * @deprecated This method will be removed soon, please use `generateCodeFromWebsite` instead.
   */
  generateLink2Code(a) {
    return N(this, arguments, function* (t, n = {}, r) {
      let i = t.tracking;
      C(this, O) && "userId" in C(this, O) && C(this, O).userId && (i != null && i.externalId || (i = { externalId: C(this, O).userId }));
      const s = {
        tracking: i,
        assetsStorage: t.assetsStorage,
        params: t.params
      };
      return De(this, he, st).call(this, "/v1/l2c", s, n, "l2c", r);
    });
  }
}
O = new WeakMap(), mt = new WeakMap(), he = new WeakSet(), sa = function(t, n, r) {
  return N(this, null, function* () {
    const i = n.map(
      (s) => zo(t, s, r)
    ).find(
      (s) => !s.isValid
    );
    if (i)
      throw new Oe({
        name: "Task Crashed",
        reason: i.reason
      });
  });
}, st = function(t, n, r, a, i) {
  return N(this, null, function* () {
    var v, j, I, D, ce, Ee, pe, H, me, vt, bt;
    if (this.hasAuth() === !1)
      throw new Error('It needs to set "auth" before calling this method.');
    const s = {}, o = Xi(JSON.stringify(n)), l = yield fetch(`${C(this, mt)}${t}`, {
      method: "POST",
      headers: b(d({}, this.headers), {
        Accept: "text/event-stream",
        "Content-Encoding": "gzip",
        "Content-Type": "application/json"
      }),
      body: o,
      signal: i
    });
    if (!l.ok) {
      const R = yield l.text();
      let W;
      try {
        W = JSON.parse(R);
      } catch ($e) {
      }
      throw ((v = W == null ? void 0 : W.error) == null ? void 0 : v.name) === "ZodError" ? (console.log(
        "Zod validation error:",
        JSON.stringify(W.error.issues, null, 2)
      ), new Oe({
        name: "HTTP error from Anima API",
        reason: "Invalid body payload",
        detail: W.error.issues,
        status: l.status
      })) : typeof W == "object" ? new Oe({
        name: `Error "${W}"`,
        reason: "Unknown",
        status: l.status
      }) : new Oe({
        name: "HTTP error from Anima API",
        reason: R,
        status: l.status
      });
    }
    if (!l.body)
      throw new Oe({
        name: "Stream Error",
        reason: "Response body is null",
        status: l.status
      });
    const c = l.body.getReader(), f = new TextDecoder();
    let m = "";
    try {
      for (; ; ) {
        const { done: R, value: W } = yield c.read();
        if (R)
          break;
        m += f.decode(W, { stream: !0 });
        const $e = m.split(`
`);
        m = $e.pop() || "";
        for (const $ of $e)
          if (!(!$.trim() || $.startsWith(":")) && $.startsWith("data: ")) {
            let S;
            try {
              S = JSON.parse($.slice(6));
            } catch (Uo) {
              continue;
            }
            switch (S.type) {
              case "queueing": {
                typeof r == "function" ? r(S) : (j = r.onQueueing) == null || j.call(r, {
                  sessionId: S.sessionId
                });
                break;
              }
              case "start": {
                s.sessionId = S.sessionId, typeof r == "function" ? r(S) : (I = r.onStart) == null || I.call(r, { sessionId: S.sessionId });
                break;
              }
              case "pre_codegen": {
                a === "codegen" && (typeof r == "function" ? r(S) : (D = r.onPreCodegen) == null || D.call(r, {
                  message: S.message
                }));
                break;
              }
              case "assets_uploaded": {
                typeof r == "function" ? r(S) : (ce = r.onAssetsUploaded) == null || ce.call(r);
                break;
              }
              case "assets_list": {
                s.assets = S.payload.assets, typeof r == "function" ? r(S) : (Ee = r.onAssetsList) == null || Ee.call(r, S.payload);
                break;
              }
              case "figma_metadata": {
                a === "codegen" && (s.figmaFileName = S.figmaFileName, s.figmaSelectedFrameName = S.figmaSelectedFrameName, typeof r == "function" ? r(S) : (pe = r.onFigmaMetadata) == null || pe.call(r, {
                  figmaFileName: S.figmaFileName,
                  figmaSelectedFrameName: S.figmaSelectedFrameName
                }));
                break;
              }
              case "generating_code": {
                S.payload.status === "success" && (s.files = S.payload.files), typeof r == "function" ? r(S) : (H = r.onGeneratingCode) == null || H.call(r, {
                  status: S.payload.status,
                  progress: S.payload.progress,
                  files: S.payload.files
                });
                break;
              }
              case "progress_messages_updated": {
                typeof r == "function" ? r(S) : (me = r.onProgressMessagesUpdated) == null || me.call(
                  r,
                  S.payload.progressMessages
                );
                break;
              }
              case "job_status_updated": {
                typeof r == "function" ? r(S) : (vt = r.onJobStatusUpdated) == null || vt.call(r, S.payload.jobStatus);
                break;
              }
              case "codegen_completed":
              case "generation_completed": {
                typeof r == "function" ? r(S) : (bt = r.onCodegenCompleted) == null || bt.call(r);
                break;
              }
              case "error":
                throw new Oe({
                  name: S.payload.errorName,
                  reason: S.payload.reason
                });
              case "done":
                return s.tokenUsage = S.payload.tokenUsage, s.sessionId = S.payload.sessionId, s;
            }
          }
      }
    } finally {
      c.cancel();
    }
    throw new Oe({
      name: "Connection",
      reason: "Connection closed before the 'done' message",
      status: 500
    });
  });
};
const Ko = (e) => {
  var t;
  if (!e)
    return [!1, "", ""];
  try {
    const n = new URL(e), r = n.pathname;
    if (n.origin !== "https://www.figma.com" && n.origin !== "https://embed.figma.com")
      return [!1, "", ""];
    const a = n.toString();
    if (e !== a)
      return [!1, "", ""];
    const i = ((t = n.searchParams.get("node-id")) != null ? t : "").replace(/-/g, ":"), s = r.split("/")[2];
    return [(r.startsWith("/file/") && n.searchParams.get("type") !== "whiteboard" || r.startsWith("/design/") || r.startsWith("/proto/")) && s.length === 22, s, i];
  } catch (n) {
    return [!1, "", ""];
  }
}, Jo = ({
  fileKey: e,
  nodeId: t,
  duplicate: n
}) => {
  const r = new URL("https://www.figma.com");
  return r.pathname = `design/${e}`, n && (r.pathname = `${r.pathname}/dummy/duplicate`), t && r.searchParams.set("node-id", t.replace(":", "-")), r;
};
class Xo extends Error {
  constructor(t, n) {
    super(t), this.response = n;
  }
}
const Go = ({
  files: e,
  screenPath: t = "src/screens"
}) => {
  const n = {}, r = /* @__PURE__ */ new Set();
  function a(i) {
    if (r.has(i) || !e[i])
      return;
    r.add(i), n[i] = e[i], jo(e[i].content).forEach((o) => {
      try {
        const l = $o(i, o);
        if (l.startsWith("src/")) {
          const c = l.split("/").slice(0, -1).join("/");
          Do(e, c).forEach((m) => {
            r.has(m) || a(m);
          });
        }
      } catch (l) {
        console.warn(
          `Failed to resolve import ${o} in ${i}:`,
          l
        );
      }
    });
  }
  return Object.entries(e).forEach(([i, s]) => {
    i.startsWith(t) ? a(i) : i.startsWith("src/") || (n[i] = s);
  }), n;
};
function jo(e) {
  const t = /import.*?["']([^"']+)["']/g, n = /export.*from\s+["']([^"']+)["']/g, r = [];
  let a;
  for (; (a = t.exec(e)) !== null; )
    r.push(a[1]);
  for (; (a = n.exec(e)) !== null; )
    r.push(a[1]);
  return [...new Set(r)];
}
function $o(e, t) {
  if (!t.startsWith("."))
    return t;
  const n = e.split("/").slice(0, -1), r = t.split("/"), a = [...n];
  for (const i of r)
    i === ".." ? a.pop() : i !== "." && a.push(i);
  return a.join("/");
}
function Do(e, t) {
  return Object.keys(e).filter((n) => n.startsWith(t));
}
function Pt(e, t, n) {
  return new ReadableStream({
    start(r) {
      n.call(e, t, (a) => {
        a.type === "error" || r.enqueue(a), (a.type === "aborted" || a.type === "error") && r.close();
      }).then((a) => {
        r.enqueue({
          type: "done",
          payload: {
            tokenUsage: a.tokenUsage,
            sessionId: a.sessionId
          }
        }), r.close();
      }).catch((a) => {
        r.enqueue({
          type: "error",
          payload: {
            name: "name" in a ? a.name : "Unknown error",
            message: "message" in a ? a.message : "Unknown",
            status: "status" in a ? a.status : void 0,
            detail: "detail" in a ? a.detail : void 0,
            errorPayload: "payload" in a ? a.payload : void 0
          }
        }), r.close();
      });
    }
  });
}
const Lo = (e, t) => Pt(e, t, e.generateCode);
function Ut(e) {
  return N(this, null, function* () {
    var s, o, l, c;
    const [t, n] = e.tee(), r = yield t.getReader().read();
    if (r.done || !r.value || r.value.type === "error" && ((s = r.value.payload) != null && s.status))
      return new Response(JSON.stringify(r.value), {
        status: ((o = r.value) == null ? void 0 : o.type) === "error" && (c = (l = r.value.payload) == null ? void 0 : l.status) != null ? c : 500,
        headers: {
          "Content-Type": "application/json"
        }
      });
    const a = new TextEncoder(), i = n.pipeThrough(
      new TransformStream({
        transform(f, m) {
          const v = `event: ${f.type}
data: ${JSON.stringify(
            f
          )}

`;
          m.enqueue(a.encode(v));
        }
      })
    );
    return new Response(i, {
      status: 200,
      headers: {
        "Content-Type": "text/event-stream; charset=utf-8",
        Connection: "keep-alive",
        "Cache-Control": "no-cache"
      }
    });
  });
}
const Yo = (e, t) => N(null, null, function* () {
  const n = Lo(e, t);
  return Ut(n);
}), Mo = (e, t) => Pt(e, t, e.generateCodeFromWebsite), Qo = (e, t) => N(null, null, function* () {
  const n = Mo(e, t);
  return Ut(n);
}), Fo = (e, t) => Pt(e, t, e.generateCodeFromPrompt), el = (e, t) => N(null, null, function* () {
  const n = Fo(e, t);
  return Ut(n);
}), Po = (e, t) => Pt(e, t, e.generateLink2Code), tl = (e, t) => N(null, null, function* () {
  const n = Po(e, t);
  return Ut(n);
});
export {
  qo as Anima,
  Oe as CodegenError,
  Gi as FigmaTokenIssue,
  es as NotFound,
  Yi as RateLimitExceeded,
  Qi as RequestTooLarge,
  Xo as ResponseError,
  ns as UnknownFigmaApiException,
  el as createCodeFromPromptResponseEventStream,
  Fo as createCodeFromPromptStream,
  Qo as createCodeFromWebsiteResponseEventStream,
  Mo as createCodeFromWebsiteStream,
  Yo as createCodegenResponseEventStream,
  Lo as createCodegenStream,
  tl as createLink2CodeResponseEventStream,
  Po as createLink2CodeStream,
  na as findChildrenNode,
  Jo as formatToFigmaLink,
  Ho as getFigmaApiErrorType,
  eo as getFigmaFile,
  Wo as getFileNodes,
  Go as getRelatedScreenFiles,
  as as isFigmaTokenIssue,
  zo as isNodeCodegenCompatible,
  ts as isNotFound,
  rs as isRateLimitExceeded,
  is as isRequestTooLarge,
  Bo as isUnknownFigmaApiException,
  Ko as isValidFigmaUrl,
  Zo as validateSettings,
  Xr as wrapFigmaApiError
};
//# sourceMappingURL=index.js.map
